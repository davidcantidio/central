# . - mandalecas bkp.py

from datetime import datetime
from common.models import DeliveryCategoryEnum, Client, DeliveryControl
from sqlalchemy.orm import Session
from sqlalchemy.sql import func
import streamlit as st  

def calcular_mandalecas(cliente_id: int, data_inicio: datetime, data_fim: datetime, session: Session):
    """
    Calcula as mandalecas contratadas, usadas e acumuladas para um cliente espec√≠fico.

    Par√¢metros:
    - cliente_id (int): ID do cliente.
    - data_inicio (datetime): Data de in√≠cio do per√≠odo.
    - data_fim (datetime): Data de fim do per√≠odo.
    - session (Session): Sess√£o do SQLAlchemy.

    Retorna:
    - mandalecas_contratadas (dict): Mandalecas contratadas por categoria.
    - mandalecas_usadas (dict): Mandalecas usadas por categoria.
    - mandalecas_acumuladas (dict): Mandalecas acumuladas por categoria.
    """

    # Obter o cliente
    cliente = session.query(Client).filter(Client.id == cliente_id).first()
    if not cliente:
        st.error(f"Cliente com ID {cliente_id} n√£o encontrado.")
        return None, None, None

    # Mandalecas Contratadas
    mandalecas_contratadas = {
        DeliveryCategoryEnum.CONTENT_PRODUCTION: cliente.n_monthly_contracted_content_production_mandalecas or 0,
        # Adicione outras categorias conforme necess√°rio
    }

    # Mandalecas Acumuladas
    mandalecas_acumuladas = {
        DeliveryCategoryEnum.CONTENT_PRODUCTION: cliente.accumulated_content_production_mandalecas or 0,
        # Adicione outras categorias conforme necess√°rio
    }

    # Mandalecas Usadas no per√≠odo atual
    mandalecas_usadas = {}

    # Calcular mandalecas usadas para 'Produ√ß√£o de Conte√∫do'
    total_usadas = session.query(func.sum(DeliveryControl.used_mandalecas)).filter(
        DeliveryControl.client_id == cliente_id,
        DeliveryControl.delivery_category == DeliveryCategoryEnum.CONTENT_PRODUCTION,
        DeliveryControl.job_creation_date.between(data_inicio, data_fim)
    ).scalar() or 0

    mandalecas_usadas[DeliveryCategoryEnum.CONTENT_PRODUCTION] = total_usadas

    return mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas


# . - gauge bkp.py

import plotly.graph_objects as go
import streamlit as st

def display_gauge_chart(title, contracted, used, accumulated=0):
    """
    Fun√ß√£o para exibir um gr√°fico de medidor (gauge) que mostra os valores contratados, usados e acumulados.

    :param title: T√≠tulo do medidor.
    :param contracted: Valor contratado.
    :param used: Valor usado at√© o momento.
    :param accumulated: Valor acumulado (positivo ou negativo).
    """
    if accumulated < 0:
        # Quando o acumulado √© negativo, considera um d√©ficit
        max_value = contracted  # Mant√©m o max_value como o contratado quando h√° um d√©ficit
        deficit_start = contracted + accumulated  # In√≠cio do d√©ficit (valor menor que o contratado)
        steps = [
            {'range': [0, deficit_start], 'color': "lightgray"},  # Intervalo at√© o in√≠cio do d√©ficit
            {'range': [deficit_start, contracted], 'color': "red"}  # Intervalo do d√©ficit
        ]
        accumulated_color = 'red'
    else:
        # Caso contr√°rio, o acumulado √© positivo
        max_value = contracted + accumulated
        steps = [
            {'range': [0, contracted], 'color': "lightgray"},
            {'range': [contracted, max_value], 'color': "orange"}
        ]
        accumulated_color = 'orange'

    # Cria o gr√°fico de medidor (gauge)
    fig = go.Figure(go.Indicator(
        mode="gauge+number",
        value=used,
        title={'text': title, 'font': {'size': 20}},
        number={'font': {'size': 40}},
        gauge={
            'axis': {'range': [0, max_value], 'tickwidth': 1, 'tickcolor': "darkblue"},
            'bar': {'color': "green"},
            'steps': steps,
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': contracted
            }
        }
    ))

    # Configura o layout e estilo do gr√°fico
    fig.update_layout(
        autosize=False,
        width=350,
        height=250,
        margin=dict(l=20, r=20, t=50, b=100),
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        annotations=[
            dict(
                x=0.15, y=-0.05, xref='paper', yref='paper',
                text=f"Contratado: {contracted}",
                showarrow=False,
                font=dict(color="white", size=12),
                xanchor='center',
                yanchor='top',
                bgcolor='green',
                borderpad=5,
                borderwidth=2,
                bordercolor='rgba(0,0,0,0)',
                opacity=1
            ),
            dict(
                x=0.8, y=-0.05, xref='paper', yref='paper',
                text=f"<b>Acumulado:</b> {accumulated}",
                showarrow=False,
                font=dict(color="white", size=12),
                xanchor='center',
                yanchor='top',
                bgcolor=accumulated_color,  # Cor de fundo din√¢mica baseada no acumulado
                borderpad=5,
                borderwidth=2,
                bordercolor='rgba(0,0,0,0)',
                opacity=1
            )
        ]
    )

    # Renderiza o gr√°fico no Streamlit
    st.plotly_chart(fig, use_container_width=True)



# . - page_entregas.py

import streamlit as st
import pandas as pd
import logging
from sqlalchemy.orm import Session
from common.models import AttentionPoints, Client
from datetime import datetime, date, timedelta
import locale
from page_entregas.attention_points.attention_points_table import display_attention_points_table
from page_entregas.content_production.content_production_table import display_content_production_table
from page_entregas.content_production.content_production_gauge import display_content_production_gauge
from page_entregas.utils.mandalecas import calcular_mandalecas
from streamlit_extras.stylable_container import stylable_container

# Configurar a localidade para portugu√™s do Brasil
try:
    locale.setlocale(locale.LC_TIME, 'pt_BR.utf8')
except locale.Error:
    locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')  # Para Windows

# Configura√ß√£o de logging
logging.basicConfig(filename='debug_log.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Configura√ß√µes iniciais do Streamlit
st.set_page_config(layout="wide")

def page_entregas(engine):
    logging.debug("Entrando na fun√ß√£o page_entregas()")

    # ===========================================================
    # Se√ß√£o de Seletores de Cliente e Intervalo de Datas na Barra Lateral
    # ===========================================================

    st.sidebar.title("Filtros")

    # Obter a lista de clientes
    clientes_df = get_clientes(engine)

    # Verificar se h√° clientes dispon√≠veis
    if clientes_df.empty:
        st.error("Nenhum cliente dispon√≠vel.")
        return

    # Inicializar o st.session_state para data_inicio e data_fim, se necess√°rio
    if "data_inicio" not in st.session_state:
        st.session_state["data_inicio"] = date.today() - timedelta(days=30)
    if "data_fim" not in st.session_state:
        st.session_state["data_fim"] = date.today()
    if "cliente_id" not in st.session_state:
        st.session_state["cliente_id"] = clientes_df["id"].iloc[0]

    # Criar um formul√°rio na barra lateral para os seletores
    with st.sidebar.form(key='filters_form'):
        # Seletor de Cliente
        options = clientes_df["id"].tolist()

        # Usar st.session_state["cliente_id"] como valor inicial para manter a sele√ß√£o atual
        cliente_id = st.selectbox(
            "Selecione o Cliente",
            options=options,
            index=options.index(st.session_state["cliente_id"]),
            format_func=lambda x: clientes_df[clientes_df["id"] == x]["name"].values[0],
            key="cliente_id_temp"  # Usar uma chave tempor√°ria para o seletor
        )

        # Seletor de Intervalo de Datas
        date_range = st.date_input(
            "Selecione o Intervalo de Datas",
            value=(st.session_state["data_inicio"], st.session_state["data_fim"]),
            key="date_range"
        )

        # Bot√£o para aplicar os filtros
        submit_button = st.form_submit_button(label='Aplicar Filtros')

    # Verifica se o bot√£o foi clicado
    if submit_button:
        # Atualizar o cliente selecionado no session_state
        st.session_state["cliente_id"] = cliente_id
        # Validar o intervalo de datas
        if isinstance(date_range, tuple) and len(date_range) == 2:
            data_inicio, data_fim = date_range
            # Atualizar o st.session_state com os valores selecionados
            st.session_state["data_inicio"] = data_inicio
            st.session_state["data_fim"] = data_fim
            logging.debug("Filtros aplicados. Reexecutando a p√°gina.")
            st.rerun()
        else:
            st.error("Por favor, selecione um intervalo de datas v√°lido.")

    # Log dos valores selecionados
    logging.debug(f"Cliente selecionado: {st.session_state['cliente_id']}")
    logging.debug(f"Data in√≠cio: {st.session_state['data_inicio']}, Data fim: {st.session_state['data_fim']}")

    # Obter o cliente selecionado e armazenar no st.session_state
    with Session(bind=engine) as session:
        cliente_selecionado = session.query(Client).filter(Client.id == st.session_state["cliente_id"]).first()
        if cliente_selecionado:
            st.session_state["cliente_obj"] = cliente_selecionado
        else:
            st.error("Cliente n√£o encontrado.")
            return

    # Obter o nome do cliente selecionado
    cliente_nome = cliente_selecionado.name
    cliente_logo_url = cliente_selecionado.logo_url

    # Exibir o nome do cliente selecionado na p√°gina principal
    if cliente_logo_url:
        col1, col2 = st.columns([1, 5])  # Ajuste as propor√ß√µes das colunas conforme necess√°rio

        with col1:
            st.image(cliente_logo_url, width=50)  # Exibe a logo do cliente com uma largura ajustada
        with col2:
            st.write(f"## {cliente_nome}")
    else:
        st.write(f"## {cliente_nome}")

    # ===========================================================
    # Exibir Pontos de Aten√ß√£o
    # ===========================================================

    display_attention_points_table(
        st.session_state["cliente_id"],
        st.session_state["data_inicio"],
        st.session_state["data_fim"],
        engine
    )

    # ===========================================================
    # Exibir Produ√ß√£o de Conte√∫do
    # ===========================================================

    # Calcular mandalecas para o gauge de produ√ß√£o de conte√∫do
    with Session(bind=engine) as session:
        mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas = calcular_mandalecas(
            st.session_state["cliente_obj"],
            st.session_state["data_inicio"],
            st.session_state["data_fim"],
            session
        )

    # Criar colunas para o gauge e a tabela
    col_gauge, col_table = st.columns([0.3, 0.7])

    with col_gauge:
        # Exibir o gauge de Produ√ß√£o de Conte√∫do
        display_content_production_gauge(
            mandalecas_contratadas,
            mandalecas_usadas,
            mandalecas_acumuladas
        )

    with col_table:
        # Exibir a tabela de Produ√ß√£o de Conte√∫do
        display_content_production_table(
            st.session_state["cliente_id"],
            st.session_state["data_inicio"],
            st.session_state["data_fim"],
            engine
        )

# Fun√ß√£o para obter a lista de clientes do banco de dados
def get_clientes(engine):
    with Session(bind=engine) as session:
        clientes = session.query(Client).all()
        clientes_df = pd.DataFrame([{'id': c.id, 'name': c.name, 'logo_url': c.logo_url} for c in clientes])
    return clientes_df

# ===========================================================
# Fun√ß√£o principal para executar a p√°gina
# ===========================================================
if __name__ == "__main__":
    from common.database import create_engine_and_session
    engine = create_engine_and_session()

    # Executar a fun√ß√£o principal
    page_entregas(engine)


# blog_text - blog_gauge.py

import streamlit as st
from plotly.graph_objects import Figure
from streamlit_extras.stylable_container import stylable_container
from page_entregas.utils.gauge import display_gauge_chart

# ===========================================================
# Fun√ß√µes para Exibi√ß√£o do Gauge de Texto de Blog
# ===========================================================

def display_blog_text_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
    """
    Exibe o gauge (gr√°fico de medidor) de uso de mandalecas para texto de blog.
    """
    st.write("**Texto de Blog**")

    with stylable_container(key="blog_text_gauge", 
                            css_styles="""
                            {
                                border: 1px solid #d3d3d3;
                                border-radius: 10px;
                                padding: 15px;
                                margin-bottom: 45px;
                            }
                            """):
        # Exibir o gr√°fico de gauge para o texto de blog
        gauge_chart = display_gauge_chart(
            title="Texto de Blog",
            contracted=mandalecas_contratadas.get('BlogText', 0),
            used=mandalecas_usadas.get('BlogText', 0),
            accumulated=mandalecas_acumuladas.get('BlogText', 0)
        )
        st.plotly_chart(gauge_chart)



# blog_text - __init__.py



# attention_points - attention_points_table.py

import streamlit as st
from streamlit_extras.stylable_container import stylable_container
import pandas as pd
from sqlalchemy.orm import Session
from common.models import AttentionPoints  # Verifique se o caminho est√° correto
import logging
from page_entregas.attention_points.attention_points_crud_modals import edit_attention_point_modal, delete_attention_point_modal, add_attention_point_modal


def display_attention_points_table(cliente_id, data_inicio, data_fim, engine):
    """
    Exibe a tabela de pontos de aten√ß√£o para um cliente, em um intervalo de datas,
    com bot√µes de Editar e Excluir, encapsulada em um container estilizado.
    """
    try:
        with Session(bind=engine) as session:
            attention_points = session.query(AttentionPoints).filter(
                AttentionPoints.client_id == cliente_id,
                AttentionPoints.date.between(data_inicio, data_fim)
            ).order_by(AttentionPoints.date.desc()).all()

        if not attention_points:
            st.info("Nenhum ponto de aten√ß√£o encontrado para o per√≠odo selecionado.")
        else:
            data = []
            for ap in attention_points:
                data.append({
                    'Data': ap.date.strftime('%d %b. %Y'),
                    'Ponto de Aten√ß√£o': ap.attention_point,
                    'ID': ap.id
                })

            attention_points_df = pd.DataFrame(data)

            # Definir o CSS para o container apenas da tabela
            css_tabela = """
            {
                border: 1px dashed lightgray;
                border-radius: 10px;
                padding: 15px;
                margin-top: 10px;
                background-color: white;
            }
            """

            # Encapsular a tabela e os bot√µes de a√ß√£o no container estilizado
            with stylable_container(
                key="tabela_attention_points",
                css_styles=css_tabela
            ):
                st.write("**Pontos de Aten√ß√£o**")
                # Exibir a tabela com bot√µes de a√ß√£o
                for index, row in attention_points_df.iterrows():
                    col1, col2, col3, col4 = st.columns([2, 7, 1, 1])
                    col1.write(row['Data'])
                    col2.write(row['Ponto de Aten√ß√£o'])
                    if col3.button('‚úèÔ∏è', key=f'edit_{row["ID"]}', help='Editar'):
                        st.session_state['edit_item_id'] = row['ID']
                        st.session_state['edit_modal_open'] = True  # Abrir modal de edi√ß√£o
                    if col4.button('üóëÔ∏è', key=f'delete_{row["ID"]}', help='Excluir'):
                        st.session_state['delete_item_id'] = row['ID']
                        st.session_state['delete_modal_open'] = True  # Abrir modal de exclus√£o
        add_attention_point_modal(engine)

        # Processar edi√ß√£o - abrir o modal ao clicar no bot√£o de editar
        if st.session_state.get('edit_modal_open'):
            edit_attention_point_modal(engine, st.session_state['edit_item_id'])

        # Processar exclus√£o - abrir o modal ao clicar no bot√£o de excluir
        if st.session_state.get('delete_modal_open'):
            delete_attention_point_modal(engine, st.session_state['delete_item_id'])

    except Exception as e:
        st.error(f"Erro ao carregar pontos de aten√ß√£o: {e}")
        logging.error(f"Erro ao carregar pontos de aten√ß√£o: {e}")
    


# attention_points - __init__.py



# attention_points - attention_points_crud_modals.py

import streamlit as st
from streamlit_modal import Modal
from sqlalchemy.orm import Session
import logging
from common.models import AttentionPoints
from datetime import datetime

def edit_attention_point_modal(engine, item_id):
    # Criar e configurar o modal
    modal = Modal("Editar Ponto de Aten√ß√£o", key=f'edit_modal_{item_id}', padding=20, max_width=744)

    # Verificar se o modal est√° aberto
    st.write(f"Modal aberto: {st.session_state.get('edit_modal_open', False)}")

    if st.session_state.get('edit_modal_open', False):
        with Session(bind=engine) as session:
            attention_point = session.query(AttentionPoints).get(item_id)

            if attention_point is None:
                st.error("Ponto de aten√ß√£o n√£o encontrado.")
                st.session_state['edit_modal_open'] = False  # Fechar o modal
                return

            # Exibir o formul√°rio para depura√ß√£o (fora do modal temporariamente)
            with st.form(key=f'edit_form_{item_id}'):
                selected_date = st.date_input("Selecione a Data do Ponto de Aten√ß√£o", value=attention_point.date)
                attention_description = st.text_area("Descri√ß√£o do Ponto de Aten√ß√£o", value=attention_point.attention_point)
                submit_edit = st.form_submit_button(label='Salvar Altera√ß√µes')

                # Verificar se o bot√£o foi clicado
                if submit_edit:
                    st.write('Detectei o clique no bot√£o')

                    if attention_description:
                        try:
                            attention_point.date = selected_date
                            attention_point.attention_point = attention_description
                            session.commit()
                            st.success("Ponto de aten√ß√£o atualizado com sucesso!")
                            st.session_state['edit_item_id'] = None
                            st.session_state['edit_modal_open'] = False
                            st.rerun()
                        except Exception as e:
                            st.error(f"Erro ao atualizar o ponto de aten√ß√£o: {e}")
                    else:
                        st.error("A descri√ß√£o do ponto de aten√ß√£o n√£o pode estar vazia.")


def delete_attention_point_modal(engine, item_id):
    """
    Exibe o modal de confirma√ß√£o de exclus√£o do ponto de aten√ß√£o.
    """
    modal = Modal("Excluir Ponto de Aten√ß√£o", key=f'delete_modal_{item_id}', padding=20, max_width=744)

    # Abrir o modal se o bot√£o de exclus√£o foi clicado
    if st.session_state.get('delete_modal_open', False):
        with Session(bind=engine) as session:
            attention_point = session.query(AttentionPoints).get(item_id)

            if attention_point is None:
                st.error("Ponto de aten√ß√£o n√£o encontrado.")
                st.session_state['delete_modal_open'] = False  # Fechar o modal se o item n√£o for encontrado
                return

            # Exibir o conte√∫do do modal
            with modal.container():
                st.write("### Excluir Ponto de Aten√ß√£o")
                st.warning(f"Tem certeza que deseja excluir o ponto de aten√ß√£o do dia {attention_point.date.strftime('%d %b. %Y')}? Esta a√ß√£o n√£o pode ser desfeita.")

                # Bot√µes de confirma√ß√£o e cancelamento
                col1, col2 = st.columns(2)
                with col1:
                    confirm_delete = st.button("Excluir", key=f'confirm_delete_{item_id}')
                with col2:
                    cancel_delete = st.button("Cancelar", key=f'cancel_delete_{item_id}')

                # Processar exclus√£o
                if confirm_delete:
                    try:
                        session.delete(attention_point)  # Deletar o ponto
                        session.commit()  # Commit da exclus√£o
                        st.success("Ponto de aten√ß√£o exclu√≠do com sucesso!")
                        st.session_state['delete_item_id'] = None  # Resetar o estado ap√≥s exclus√£o
                        st.session_state['delete_modal_open'] = False  # Fechar o modal
                        st.rerun()  # Recarregar a p√°gina
                    except Exception as e:
                        st.error(f"Erro ao excluir o ponto de aten√ß√£o: {e}")
                elif cancel_delete:
                    st.session_state['delete_modal_open'] = False  # Fechar o modal se o usu√°rio cancelar
                    st.rerun()

# Fun√ß√£o para adicionar um novo ponto de aten√ß√£o utilizando streamlit-modal
def add_attention_point_modal(engine):
    # Passo 3: Definir o modal
    modal = Modal("Adicionar Novo Ponto de Aten√ß√£o", key="adicionar_ponto_modal", padding=20, max_width=744)

    # Passo 4: Bot√£o para abrir o modal
    if st.button("Adicionar Ponto de Aten√ß√£o"):
        modal.open()

    # Passo 5: Exibir o modal se estiver aberto
    if modal.is_open():
        with modal.container():
            st.write("### Novo Ponto de Aten√ß√£o")
            # Passo 6: Exibir o formul√°rio dentro do modal
            with st.form(key='new_attention_point_form'):
                selected_date = st.date_input("Selecione a Data do Ponto de Aten√ß√£o", value=datetime.today())
                attention_description = st.text_area("Descri√ß√£o do Ponto de Aten√ß√£o")
                submit_new = st.form_submit_button(label='Salvar')

                # Manipula√ß√£o da submiss√£o
                if submit_new:
                    if attention_description:  # Verifica se a descri√ß√£o n√£o est√° vazia
                        save_new_attention_point(st.session_state["cliente_id"], selected_date, attention_description, engine)
                        st.success("Ponto de aten√ß√£o adicionado com sucesso!")
                        modal.close()  # Fechar o modal
                        st.rerun()  # Recarregar a p√°gina
                    else:
                        st.error("A descri√ß√£o do ponto de aten√ß√£o n√£o pode estar vazia.")

# Fun√ß√£o para salvar o novo ponto de aten√ß√£o no banco de dados
def save_new_attention_point(cliente_id, attention_date, attention_point, engine):
    try:
        with Session(bind=engine) as session:
            new_entry = AttentionPoints(
                client_id=cliente_id,
                date=attention_date,
                attention_point=attention_point
            )
            session.add(new_entry)
            session.commit()  # Commit da nova entrada
            st.success("Ponto de aten√ß√£o salvo com sucesso!")
    except Exception as e:
        st.error(f"Erro ao salvar o ponto de aten√ß√£o: {e}")


# paid_traffic - __init__.py



# paid_traffic - traffic_gauge.py

# import streamlit as st
# from page_entregas.utils.gauge import display_gauge_chart
# from common.models import JobCategoryEnum

# # Fun√ß√£o para exibir os gr√°ficos de gauge de tr√°fego pago
# def display_traffic_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
#     st.write("**Tr√°fego Pago**")
    
#     with st.container():
#         # Criar colunas internas para os gr√°ficos de tr√°fego pago
#         col1, col2 = st.columns(2)

#         # Gauge para Tr√°fego Pago Est√°tico
#         with col1:
#             gauge_chart_static = display_gauge_chart(
#                 title="Tr√°fego Pago (Est√°tico)",
#                 contracted=mandalecas_contratadas.get(JobCategoryEnum.STATIC_TRAFEGO_PAGO, 0),
#                 used=mandalecas_usadas.get(JobCategoryEnum.STATIC_TRAFEGO_PAGO, 0),
#                 accumulated=mandalecas_acumuladas.get(JobCategoryEnum.STATIC_TRAFEGO_PAGO, 0)
#             )
#             st.plotly_chart(gauge_chart_static, use_container_width=True)

#         # Gauge para Tr√°fego Pago Animado
#         with col2:
#             gauge_chart_animated = display_gauge_chart(
#                 title="Tr√°fego Pago (Animado)",
#                 contracted=mandalecas_contratadas.get(JobCategoryEnum.ANIMATED_TRAFEGO_PAGO, 0),
#                 used=mandalecas_usadas.get(JobCategoryEnum.ANIMATED_TRAFEGO_PAGO, 0),
#                 accumulated=mandalecas_acumuladas.get(JobCategoryEnum.ANIMATED_TRAFEGO_PAGO, 0)
#             )
#             st.plotly_chart(gauge_chart_animated, use_container_width=True)


# creation_and_adaptation - adaptation_gauge.py

# import streamlit as st
# from plotly.graph_objects import Figure
# from common.models import JobCategoryEnum
# from page_entregas.utils.gauge import display_gauge_chart


# # Fun√ß√£o para exibir o gr√°fico de Adapta√ß√£o
# def display_adaptation_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
#     st.write("**Adapta√ß√£o de Formato**")
    
#     # Container estilizado para o gr√°fico gauge
#     with st.container():
#         # Obter dados de mandalecas contratadas, usadas e acumuladas para adapta√ß√£o de formato
#         contracted = mandalecas_contratadas.get(JobCategoryEnum.ADAPTACAO, 0)
#         used = mandalecas_usadas.get(JobCategoryEnum.ADAPTACAO, 0)
#         accumulated = mandalecas_acumuladas.get(JobCategoryEnum.ADAPTACAO, 0)

#         # Gerar o gr√°fico gauge de adapta√ß√£o usando a fun√ß√£o utilit√°ria
#         gauge_chart = display_gauge_chart(
#             title="Adapta√ß√£o de Formato",
#             contracted=contracted,
#             used=used,
#             accumulated=accumulated
#         )

#         # Exibir o gr√°fico
#         st.plotly_chart(gauge_chart, use_container_width=True)


# creation_and_adaptation - __init__.py



# creation_and_adaptation - creation_gauge.py

# import streamlit as st
# from plotly.graph_objects import Figure
# from common.models import JobCategoryEnum
# from page_entregas.utils.gauge import display_gauge_chart


# # Fun√ß√£o para exibir o gr√°fico de Cria√ß√£o
# def display_creation_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
#     st.write("**Cria√ß√£o**")
    
#     # Container estilizado para o gr√°fico gauge
#     with st.container():
#         # Obter dados de mandalecas contratadas, usadas e acumuladas para cria√ß√£o
#         contracted = mandalecas_contratadas.get(JobCategoryEnum.CRIACAO, 0)
#         used = mandalecas_usadas.get(JobCategoryEnum.CRIACAO, 0)
#         accumulated = mandalecas_acumuladas.get(JobCategoryEnum.CRIACAO, 0)

#         # Gerar o gr√°fico gauge de cria√ß√£o usando a fun√ß√£o utilit√°ria
#         gauge_chart = display_gauge_chart(
#             title="Cria√ß√£o",
#             contracted=contracted,
#             used=used,
#             accumulated=accumulated
#         )

#         # Exibir o gr√°fico
#         st.plotly_chart(gauge_chart, use_container_width=True)


# social_media - social_media_gauges.py

# import streamlit as st
# from page_entregas.utils.gauge import display_gauge_chart
# from common.models import JobCategoryEnum
# from streamlit_extras.stylable_container import stylable_container
# import plotly.graph_objects as go  # Importa√ß√£o para criar gr√°ficos com Plotly


# # Fun√ß√£o para exibir o medidor do Instagram
# def display_instagram_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
#     st.write("**Instagram**")
#     with stylable_container(key="instagram_gauge", 
#                             css_styles="""
#                             {
#                                 border: 1px solid #d3d3d3;
#                                 border-radius: 10px;
#                                 padding: 15px;
#                                 margin-bottom: 45px;
#                             }
#                             """):
#         gauge_chart = display_gauge_chart(
#             title="Instagram",
#             contracted=mandalecas_contratadas.get(JobCategoryEnum.FEED_INSTAGRAM, 0),
#             used=mandalecas_usadas.get(JobCategoryEnum.FEED_INSTAGRAM, 0),
#             accumulated=mandalecas_acumuladas.get(JobCategoryEnum.FEED_INSTAGRAM, 0)
#         )
#         st.plotly_chart(gauge_chart)

#         # Distribui√ß√£o do uso de conte√∫do no Instagram
#         social_media_data = {
#             "Carrossel Instagram": mandalecas_usadas.get(JobCategoryEnum.CAROUSEL_INSTAGRAM, 0),
#             "Reels Instagram": mandalecas_usadas.get(JobCategoryEnum.REELS_INSTAGRAM, 0),
#             "Card Instagram": mandalecas_usadas.get(JobCategoryEnum.CARD_INSTAGRAM, 0)
#         }

#         pie_chart = create_pie_chart(social_media_data, "Distribui√ß√£o Instagram")
#         st.plotly_chart(pie_chart)


# # Fun√ß√£o para exibir o medidor de outras redes (LinkedIn, TikTok)
# def display_other_networks_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
#     st.write("**Outras Redes**")
#     with stylable_container(key="other_networks_gauge", 
#                             css_styles="""
#                             {
#                                 border: 1px solid #d3d3d3;
#                                 border-radius: 10px;
#                                 padding: 15px;
#                                 margin-bottom: 45px;
#                             }
#                             """):
#         linkedin_gauge = display_gauge_chart(
#             title="Feed LinkedIn",
#             contracted=mandalecas_contratadas.get(JobCategoryEnum.FEED_LINKEDIN, 0),
#             used=mandalecas_usadas.get(JobCategoryEnum.FEED_LINKEDIN, 0),
#             accumulated=mandalecas_acumuladas.get(JobCategoryEnum.FEED_LINKEDIN, 0)
#         )
#         st.plotly_chart(linkedin_gauge)

#         tiktok_gauge = display_gauge_chart(
#             title="Feed TikTok",
#             contracted=mandalecas_contratadas.get(JobCategoryEnum.FEED_TIKTOK, 0),
#             used=mandalecas_usadas.get(JobCategoryEnum.FEED_TIKTOK, 0),
#             accumulated=mandalecas_acumuladas.get(JobCategoryEnum.FEED_TIKTOK, 0)
#         )
#         st.plotly_chart(tiktok_gauge)


# def create_pie_chart(data, title):
#     labels = list(data.keys())
#     values = list(data.values())
#     fig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=.3)])
#     fig.update_layout(title_text=title)
#     return fig

# social_media - __init__.py



# website_maintenance - website_gauge_timeline.py

# import streamlit as st
# from page_entregas.utils.gauge import display_gauge_chart
# from page_entregas.utils.timeline import render_timeline_chart_with_multiple_events
# from common.models import JobCategoryEnum
# from streamlit_extras.stylable_container import stylable_container
# from page_entregas.website_maintenance.website_modal  import modal_website_maintenance_open
# from datetime import datetime, timedelta
# import calendar

# # Fun√ß√£o para exibir o medidor e a linha do tempo para manuten√ß√£o de websites
# def display_website_maintenance_gauge_and_timeline(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas, maintenance_dates):
#     st.write("**Manuten√ß√£o de Website**")

#     # Criar colunas para o medidor e a linha do tempo
#     col1 = st.container()

#     with col1:
#         gauge_chart = display_gauge_chart(
#             title="Manuten√ß√£o de Website",
#             contracted=mandalecas_contratadas.get(JobCategoryEnum.WEBSITE_MAINTENANCE, 0),
#             used=mandalecas_usadas.get(JobCategoryEnum.WEBSITE_MAINTENANCE, 0),
#             accumulated=mandalecas_acumuladas.get(JobCategoryEnum.WEBSITE_MAINTENANCE, 0)
#         )
#         st.plotly_chart(gauge_chart, use_container_width=True)

#     # Renderizar a linha do tempo de manuten√ß√£o de websites
#     today = datetime.today()
#     deadline_date = today.replace(day=1) + timedelta(days=calendar.monthrange(today.year, today.month)[1] - 1)
#     render_timeline_chart_with_multiple_events(today, deadline_date, maintenance_dates)

#     # Adicionar bot√£o para abrir o modal e adicionar uma nova data de manuten√ß√£o
#     if st.button("Adicionar Data de Manuten√ß√£o"):
#         modal_website_maintenance_open()


# website_maintenance - __init__.py



# website_maintenance - website_modal.py

# import streamlit as st
# from datetime import datetime
# from streamlit_modal import Modal
# from sqlalchemy.orm import Session
# from common.models import WebsiteMaintenance
# from common.database import engine
# import logging

# def modal_website_maintenance_open():
#     cliente_id = st.session_state.get("cliente_id")

#     # Inicializa o modal para adicionar manuten√ß√£o de website
#     modal = Modal("Adicionar Data de Manuten√ß√£o de Website", key="adicionar-manutencao-modal", max_width=800)

#     if modal.is_open():
#         with modal.container():
#             selected_date = st.date_input("Selecione a Data de Manuten√ß√£o", value=datetime.today())
#             if st.button("Salvar"):
#                 save_website_maintenance_date(cliente_id, selected_date)
#                 modal.close()
#                 st.success("Data de manuten√ß√£o adicionada com sucesso!")
#                 st.rerun()

# def save_website_maintenance_date(cliente_id, selected_date):
#     try:
#         with Session(bind=engine) as session:
#             new_entry = WebsiteMaintenance(
#                 client_id=cliente_id,
#                 date=selected_date
#             )
#             session.add(new_entry)
#             session.commit()
#             logging.info(f"Data de manuten√ß√£o para o cliente ID {cliente_id} adicionada com sucesso.")
#     except Exception as e:
#         st.error(f"Erro ao salvar a data de manuten√ß√£o: {e}")
#         logging.error(f"Erro ao salvar a data de manuten√ß√£o: {e}")


# utils - mandalecas.py

from datetime import datetime
from common.models import DeliveryCategoryEnum, Client, DeliveryControl
from sqlalchemy.orm import Session
from sqlalchemy.sql import func
import streamlit as st  

def calcular_mandalecas(cliente: Client, data_inicio: datetime, data_fim: datetime, session: Session):
    """
    Calcula as mandalecas contratadas, usadas e acumuladas para um cliente espec√≠fico.

    Par√¢metros:
    - cliente (Client): Objeto do cliente.
    - data_inicio (datetime): Data de in√≠cio do per√≠odo.
    - data_fim (datetime): Data de fim do per√≠odo.
    - session (Session): Sess√£o do SQLAlchemy.

    Retorna:
    - mandalecas_contratadas (dict): Mandalecas contratadas por categoria.
    - mandalecas_usadas (dict): Mandalecas usadas por categoria.
    - mandalecas_acumuladas (dict): Mandalecas acumuladas por categoria.
    """
    # Verificar se o cliente foi fornecido
    if not cliente:
        st.error("Cliente n√£o fornecido.")
        return None, None, None

    # Mandalecas Contratadas
    mandalecas_contratadas = {
        DeliveryCategoryEnum.CONTENT_PRODUCTION: cliente.n_monthly_contracted_content_production_mandalecas or 0,
        # Adicione outras categorias conforme necess√°rio
    }

    # Mandalecas Acumuladas
    mandalecas_acumuladas = {
        DeliveryCategoryEnum.CONTENT_PRODUCTION: cliente.accumulated_content_production_mandalecas or 0,
        # Adicione outras categorias conforme necess√°rio
    }

    # Mandalecas Usadas no per√≠odo atual
    mandalecas_usadas = {}

    # Calcular mandalecas usadas para 'Produ√ß√£o de Conte√∫do'
    total_usadas = session.query(func.sum(DeliveryControl.used_mandalecas)).filter(
        DeliveryControl.client_id == cliente.id,
        DeliveryControl.delivery_category == DeliveryCategoryEnum.CONTENT_PRODUCTION,
        DeliveryControl.job_creation_date.between(data_inicio, data_fim)
    ).scalar() or 0

    mandalecas_usadas[DeliveryCategoryEnum.CONTENT_PRODUCTION] = total_usadas

    return mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas


# utils - chat_gpt.py

import os

# Caminho da pasta que voc√™ quer percorrer
caminho_projeto = '/home/debrito/Documentos/central/page_entregas'

# Arquivo de sa√≠da onde ser√° salvo o conte√∫do
arquivo_saida = 'resumo_projeto.txt'

def gerar_resumo(caminho, arquivo_saida):
    with open(arquivo_saida, 'w') as f_out:
        # Percorre todas as subpastas e arquivos
        for pasta_atual, subpastas, arquivos in os.walk(caminho):
            for arquivo in arquivos:
                # Caminho completo do arquivo
                caminho_arquivo = os.path.join(pasta_atual, arquivo)
                
                # Somente arquivos com extens√£o .py
                if arquivo.endswith('.py'):
                    # Escreve o caminho do arquivo no formato desejado
                    f_out.write(f"# {os.path.relpath(pasta_atual, caminho)} - {arquivo}\n\n")

                    # Abre o arquivo e l√™ o conte√∫do
                    with open(caminho_arquivo, 'r') as f_in:
                        conteudo = f_in.read()
                        f_out.write(conteudo)
                    
                    # Adiciona uma quebra de linha entre os arquivos
                    f_out.write("\n\n")

    print(f"Resumo gerado em {arquivo_saida}")

# Executa a fun√ß√£o para gerar o resumo
gerar_resumo(caminho_projeto, arquivo_saida)


# utils - __init__.py



# utils - cruzamento leads.py

import pandas as pd

# Fun√ß√£o para carregar arquivos TSV codificados em UTF-16
def read_tsv_utf16(filepath):
    try:
        return pd.read_csv(filepath, encoding='utf-16', delimiter='\t')
    except Exception as e:
        print(f"Error loading {filepath}: {e}")
        return pd.DataFrame()

# Caminhos dos arquivos CSV (TSV)
csv_file_paths_september = [
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_1v4DubD66G7YYil4Y1OYlybPEsVr_Syp5_Leads_2024-08-08_2024-09-29.csv',
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_1hInB0tW3O1P5GaIhf3D4w9HbKWV-nB-r _ CARD 5_Leads_2024-07-31_2024-09-29.csv',
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_1myUh2JRRD0Bu9pCqEnsugy3h23BIzBZl_Leads_2024-08-19_2024-09-29.csv',
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_1o0QgalnZd2PlTUhDN4feHgT4w3FaHfBI_Leads_2024-07-31_2024-09-29.csv',
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_15gcvkHd-POyc9sS9kbUJkXIWd1-TbmUY_Leads_2024-07-31_2024-09-29.csv',
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_1BGLLvPG8Kfv2ZryJ8yL1KPkiSgjH6UQN_Leads_2024-08-27_2024-09-29.csv'
]

# Carregar o relat√≥rio de leads de setembro
september_report_path = '/home/debrito/Documentos/cruzamento leads/setembro/Relatorio m√™s de Setembro.xlsx'
september_data = pd.read_excel(september_report_path)

# Carregar e combinar os dados CSV
tsv_dataframes_september = [read_tsv_utf16(path) for path in csv_file_paths_september]
tsv_dataframes_september = [df for df in tsv_dataframes_september if not df.empty]  # Remover dataframes vazios
combined_tsv_data_september = pd.concat(tsv_dataframes_september, ignore_index=True)

# Cruzar os dados usando o campo 'email' tanto no Excel quanto nos CSVs
merged_september_data = pd.merge(september_data, combined_tsv_data_september[['email', 'ad_name']], how='left', on='email')

# Exportar o resultado para um arquivo Excel
output_september_file_path = '/home/debrito/Documentos/cruzamento leads/setembro/Merged_Leads_September_Data.xlsx'
merged_september_data.to_excel(output_september_file_path, index=False)

print(f"Arquivo final salvo em: {output_september_file_path}")


# utils - assessoria_plan_utils.py

import logging
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy.sql import func
from common.models import Client, RedesSociaisPlan, RedesSociaisGuidance, RedesSociaisPlanStatusEnum
from common.database import engine
import streamlit as st

# Fun√ß√£o para salvar a data de envio de um plano ou direcionamento
def salvar_data_envio(cliente_id, data_envio, model_class, status_function):
    logging.info(f"Salvando data de envio para cliente ID {cliente_id} com data {data_envio}")
    with Session(bind=engine) as session:
        try:
            if isinstance(data_envio, datetime):
                data_envio = data_envio.date()

            mes_inicio = data_envio.replace(day=1)
            logging.debug(f"Buscando registro existente para cliente ID {cliente_id} no m√™s {mes_inicio.strftime('%Y-%m')}")
            record = session.query(model_class).filter(
                model_class.client_id == cliente_id,
                func.strftime('%Y-%m', model_class.send_date) == mes_inicio.strftime('%Y-%m')
            ).first()

            client = session.query(Client).filter(Client.id == cliente_id).first()
            logging.debug(f"Cliente encontrado: {client}")

            # Obter o deadline_day do cliente
            if model_class == RedesSociaisPlan:
                deadline_day = client.monthly_plan_deadline_day
            elif model_class == RedesSociaisGuidance:
                deadline_day = client.monthly_redes_guidance_deadline_day
            else:
                raise ValueError("Classe de modelo desconhecida para determina√ß√£o do deadline_day")

            if record:
                logging.debug(f"Registro encontrado, atualizando data de envio e status")
                record.send_date = data_envio
                record.updated_at = datetime.now()
                record.status = status_function(client, record, deadline_day)
            else:
                logging.debug(f"Nenhum registro existente encontrado, criando novo registro")
                record = model_class(
                    client_id=cliente_id,
                    send_date=data_envio,
                    updated_at=datetime.now(),
                    status=status_function(client, None, deadline_day),
                    plan_status=RedesSociaisPlanStatusEnum.AWAITING
                )
                session.add(record)

            logging.info(f"Commitando a transa√ß√£o no banco de dados")
            session.commit()
            st.success(f"Data de envio atualizada com sucesso.")
            st.session_state['send_date'] = data_envio

        except Exception as e:
            session.rollback()
            st.error(f"Erro ao atualizar a data de envio: {e}")
            logging.error(f"Erro ao atualizar a data de envio: {e}")

# Fun√ß√£o para determinar o status do plano ou direcionamento
def determinar_status(cliente, record, deadline_day):
    hoje = datetime.today().date()
    prazo = datetime(hoje.year, hoje.month, deadline_day).date()
    
    if record is None or record.send_date is None:
        if hoje > prazo:
            return RedesSociaisPlanStatusEnum.DELAYED
        else:
            return RedesSociaisPlanStatusEnum.AWAITING
    else:
        send_date = record.send_date
        if isinstance(send_date, datetime):
            send_date = send_date.date()
        if send_date <= prazo:
            return RedesSociaisPlanStatusEnum.ON_TIME
        else:
            return RedesSociaisPlanStatusEnum.DELAYED

# Fun√ß√£o utilit√°ria para obter o range de datas do m√™s anterior
def get_last_month_date_range():
    today = datetime.today()
    first_day_of_current_month = datetime(today.year, today.month, 1)
    last_day_of_last_month = first_day_of_current_month - timedelta(days=1)
    first_day_of_last_month = datetime(last_day_of_last_month.year, last_day_of_last_month.month, 1)
    return first_day_of_last_month, last_day_of_last_month


# utils - styles.py

  # Definir o CSS para o container apenas da tabela
def css_tabela ():
    
    style = """
    {
        border: 1px dashed lightgray;
        border-radius: 10px;
        padding: 15px;
        margin-top: 10px;
        background-color: white;
    }
    """
    return style 

def css_gauge():
    style = """"
    {   border: 1px solid #d3d3d3;
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 45px;
      }
      """
    return style 

# utils - gauge.py

import plotly.graph_objects as go
import streamlit as st

def display_gauge_chart(title, contracted, used, accumulated=0):
    """
    Fun√ß√£o para exibir um gr√°fico de medidor (gauge) que mostra os valores contratados, usados e acumulados.

    :param title: T√≠tulo do medidor.
    :param contracted: Valor contratado.
    :param used: Valor usado at√© o momento.
    :param accumulated: Valor acumulado (positivo ou negativo).
    """
    if accumulated < 0:
        # Quando o acumulado √© negativo, considera um d√©ficit
        max_value = contracted  # Mant√©m o max_value como o contratado quando h√° um d√©ficit
        deficit_start = contracted + accumulated  # In√≠cio do d√©ficit (valor menor que o contratado)
        steps = [
            {'range': [0, deficit_start], 'color': "lightgray"},  # Intervalo at√© o in√≠cio do d√©ficit
            {'range': [deficit_start, contracted], 'color': "red"}  # Intervalo do d√©ficit
        ]
        accumulated_color = 'red'
    else:
        # Caso contr√°rio, o acumulado √© positivo
        max_value = contracted + accumulated
        steps = [
            {'range': [0, contracted], 'color': "lightgray"},
            {'range': [contracted, max_value], 'color': "orange"}
        ]
        accumulated_color = 'orange'

    # Cria o gr√°fico de medidor (gauge)
    fig = go.Figure(go.Indicator(
        mode="gauge+number",
        value=used,
        title={'text': title, 'font': {'size': 20}},
        number={'font': {'size': 40}},
        gauge={
            'axis': {'range': [0, max_value], 'tickwidth': 1, 'tickcolor': "darkblue"},
            'bar': {'color': "green"},
            'steps': steps,
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': contracted
            }
        }
    ))

    # Configura o layout e estilo do gr√°fico
    fig.update_layout(
        autosize=False,
        width=350,
        height=250,
        margin=dict(l=20, r=20, t=50, b=100),
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        annotations=[
            dict(
                x=0.15, y=-0.05, xref='paper', yref='paper',
                text=f"Contratado: {contracted}",
                showarrow=False,
                font=dict(color="white", size=12),
                xanchor='center',
                yanchor='top',
                bgcolor='green',
                borderpad=5,
                borderwidth=2,
                bordercolor='rgba(0,0,0,0)',
                opacity=1
            ),
            dict(
                x=0.8, y=-0.05, xref='paper', yref='paper',
                text=f"<b>Acumulado:</b> {accumulated}",
                showarrow=False,
                font=dict(color="white", size=12),
                xanchor='center',
                yanchor='top',
                bgcolor=accumulated_color,  # Cor de fundo din√¢mica baseada no acumulado
                borderpad=5,
                borderwidth=2,
                bordercolor='rgba(0,0,0,0)',
                opacity=1
            )
        ]
    )

    # Renderiza o gr√°fico no Streamlit
    st.plotly_chart(fig, use_container_width=True)



# utils - timeline.py

# import plotly.graph_objects as go
# import streamlit as st
# import pandas as pd

# def create_timeline_chart(today, deadline_date, event_date=None, event_name="Enviado"):
#     """
#     Cria um gr√°fico de linha do tempo para exibir prazos e datas de envio.
    
#     :param today: Data atual (datetime object).
#     :param deadline_date: Data do prazo (datetime object).
#     :param event_date: Data do evento, como a data de envio (datetime object), opcional.
#     :param event_name: Nome do evento (ex.: "Enviado"), opcional, padr√£o √© "Enviado".
#     :return: Objeto Plotly figure representando a linha do tempo.
#     """
#     # Gera uma lista com os dias do m√™s
#     days_in_month = [date for date in pd.date_range(start=today.replace(day=1), end=today.replace(day=28) + pd.offsets.MonthEnd(1))]
#     x_values = [day.strftime('%Y-%m-%d') for day in days_in_month]

#     # Inicializa as listas de eventos
#     event_dates = [deadline_date.strftime('%Y-%m-%d')]
#     event_colors = ["red"]
#     event_texts = ["Deadline"]

#     if event_date:
#         event_dates.append(event_date.strftime('%Y-%m-%d'))
#         event_colors.append("green")
#         event_texts.append(event_name)

#     fig = go.Figure()

#     # Adiciona a linha do tempo com os dias do m√™s
#     fig.add_trace(go.Scatter(
#         x=x_values,
#         y=[1] * len(x_values),
#         mode='lines+markers',
#         line=dict(color='lightgrey', width=2),
#         marker=dict(color='lightgrey', size=6),
#         hoverinfo='x',
#         showlegend=False
#     ))

#     # Adiciona os eventos (prazos, envio, etc.) com as legendas
#     for date, color, text in zip(event_dates, event_colors, event_texts):
#         text_position = "top center" if text == event_name else "bottom center"
#         fig.add_trace(go.Scatter(
#             x=[date],
#             y=[1],
#             mode='markers+text',
#             marker=dict(color=color, size=12),
#             text=[text],
#             textposition=text_position,
#             showlegend=False,
#             hoverinfo='none'
#         ))

#     # Configura√ß√£o do layout do gr√°fico
#     fig.update_layout(
#         xaxis=dict(
#             tickmode='array',
#             tickvals=x_values,
#             ticktext=[day.strftime('%d') for day in days_in_month],
#             showline=False,
#             showgrid=False,
#             zeroline=False,
#             tickfont=dict(size=10),
#             tickangle=0,
#             ticks='outside',
#             ticklen=4,
#             tickwidth=1,
#         ),
#         yaxis=dict(visible=False),
#         height=95,
#         margin=dict(l=20, r=20, t=10, b=10),
#         plot_bgcolor='rgba(0,0,0,0)',
#         paper_bgcolor='rgba(0,0,0,0)',
#     )

#     return fig

# def render_timeline_chart(today, deadline_date, event_date=None, event_name="Enviado"):
#     """
#     Renderiza o gr√°fico de linha do tempo no Streamlit.
    
#     :param today: Data atual (datetime object).
#     :param deadline_date: Data do prazo (datetime object).
#     :param event_date: Data do evento, como a data de envio (datetime object), opcional.
#     :param event_name: Nome do evento (ex.: "Enviado"), opcional, padr√£o √© "Enviado".
#     """
#     fig = create_timeline_chart(today, deadline_date, event_date, event_name)
#     st.plotly_chart(fig, use_container_width=True)

# def render_timeline_chart_with_multiple_events(today, deadline_date, event_dates):
#     """
#     Renderiza um gr√°fico de linha do tempo com m√∫ltiplos eventos, como manuten√ß√£o de websites.
    
#     :param today: Data atual (datetime object).
#     :param deadline_date: Data do prazo (datetime object).
#     :param event_dates: Lista de datas de eventos.
#     """
#     days_in_month = [date for date in pd.date_range(start=today.replace(day=1), end=deadline_date)]
#     x_values = [day.strftime('%Y-%m-%d') for day in days_in_month]

#     fig = go.Figure()

#     # Adicionando a linha do tempo com os dias do m√™s
#     fig.add_trace(go.Scatter(
#         x=x_values,
#         y=[1] * len(x_values),
#         mode='lines+markers',
#         line=dict(color='lightgrey', width=2),
#         marker=dict(color='lightgrey', size=6),
#         hoverinfo='x',
#         showlegend=False
#     ))

#     # Adicionando os eventos de manuten√ß√£o
#     for date in event_dates:
#         fig.add_trace(go.Scatter(
#             x=[date.strftime('%Y-%m-%d')],
#             y=[1],
#             mode='markers+text',
#             marker=dict(color='green', size=12),
#             text=["Manuten√ß√£o"],
#             textposition="top center",
#             showlegend=False,
#             hoverinfo='none'
#         ))

#     # Configura o layout do gr√°fico
#     fig.update_layout(
#         xaxis=dict(
#             tickmode='array',
#             tickvals=x_values,
#             ticktext=[day.strftime('%d') for day in days_in_month],
#             showline=False,
#             showgrid=False,
#             zeroline=False,
#             tickfont=dict(size=10),
#             tickangle=0,
#             ticks='outside',
#             ticklen=4,
#             tickwidth=1,
#         ),
#         yaxis=dict(visible=False),
#         height=150,
#         margin=dict(l=20, r=20, t=10, b=10),
#         plot_bgcolor='rgba(0,0,0,0)',
#         paper_bgcolor='rgba(0,0,0,0)',
#     )

#     # Renderiza o gr√°fico no Streamlit
#     st.plotly_chart(fig, use_container_width=True)


# plan_status - plan_timeline.py

# import streamlit as st
# from common.models import Client, RedesSociaisPlan
# from page_entregas.utils.assessoria_plan_utils import determinar_status
# from page_entregas.utils.timeline import render_timeline_chart


# from sqlalchemy.orm import Session
# from datetime import datetime, timedelta

# # Fun√ß√£o para exibir a linha do tempo do plano de redes sociais
# def display_plan_timeline(cliente_id):
#     with Session(bind=st.session_state["engine"]) as session:
#         # Busca os dados do cliente e o plano de redes sociais
#         client = session.query(Client).filter(Client.id == cliente_id).first()
#         redes_sociais_plan = session.query(RedesSociaisPlan).filter(RedesSociaisPlan.client_id == cliente_id).first()

#         # Determina o status do plano e a data de envio do plano
#         if redes_sociais_plan:
#             plan_status = determinar_status(client, redes_sociais_plan, client.monthly_plan_deadline_day)
#             if 'plan_sent_date' not in st.session_state or not st.session_state['plan_sent_date']:
#                 st.session_state['plan_sent_date'] = redes_sociais_plan.send_date
#         else:
#             plan_status = "Plano n√£o encontrado"
#             st.session_state['plan_sent_date'] = None

#         # Gera o t√≠tulo para a linha do tempo com base no pr√≥ximo m√™s
#         next_month = (datetime.now().replace(day=28) + timedelta(days=4)).strftime('%B')
#         title = f"Planejamento Redes Sociais: {next_month.capitalize()}"

#         # Exibe o t√≠tulo
#         st.write(f"**{title}**")

#         # Define a data de hoje e a data do deadline
#         today = datetime.today()
#         deadline_date = datetime(today.year, today.month, client.monthly_plan_deadline_day)

#         # Renderiza a linha do tempo do plano
#         render_timeline_chart(today, deadline_date, st.session_state['plan_sent_date'])


# plan_status - __init__.py



# plan_status - plan_modal.py

# import streamlit as st
# from page_entregas.utils.assessoria_plan_utils import salvar_data_envio, determinar_status
# from common.models import RedesSociaisPlan
# from streamlit_modal import Modal
# from datetime import datetime
# import logging

# # Fun√ß√£o para exibir o modal de envio do plano
# def display_plan_modal(cliente_id):
#     # Inicializa o modal fora dos containers estilizados
#     modal = Modal("Data de Envio do Plano", key="enviar-plano-modal", max_width=800)

#     if st.button("Enviar Plano"):
#         logging.info(f"Usu√°rio clicou no bot√£o 'Enviar Plano' para o cliente ID {cliente_id}")
#         modal.open()

#     # Verifica e abre o modal fora do container
#     if modal.is_open():
#         logging.info(f"Modal 'Data de Envio do Plano' foi aberto para o cliente ID {cliente_id}")
#         with modal.container():
#             selected_date = st.date_input("Selecione a Data de Envio", value=datetime.today())
#             if st.button("Confirmar"):
#                 logging.info(f"Tentando salvar a data de envio para o cliente ID {cliente_id}")
#                 salvar_data_envio(cliente_id, selected_date, RedesSociaisPlan, determinar_status)
#                 st.session_state['plan_sent_date'] = selected_date
#                 modal.close()  # Fecha o modal
#                 st.success("Data de envio do plano atualizada com sucesso!")
#                 st.rerun()  # Recarrega a p√°gina para refletir as mudan√ßas


# guidance_status - guidance_timeline.py

# import streamlit as st
# from datetime import datetime, timedelta
# from common.models import Client, RedesSociaisGuidance
# from page_entregas.utils.assessoria_plan_utils import determinar_status
# from page_entregas.utils.timeline import render_timeline_chart
# from sqlalchemy.orm import Session
# from common.database import engine

# # Fun√ß√£o para exibir a linha do tempo do direcionamento
# def display_guidance_timeline(cliente_id):
#     # Abrindo uma sess√£o com o banco de dados
#     with Session(bind=engine) as session:
#         # Consultando o cliente e o status do direcionamento
#         client = session.query(Client).filter(Client.id == cliente_id).first()
#         redes_sociais_guidance = session.query(RedesSociaisGuidance).filter(RedesSociaisGuidance.client_id == cliente_id).first()

#         # Verificando se o direcionamento existe
#         if redes_sociais_guidance:
#             # Determina o status do direcionamento e recupera a data de envio
#             guidance_status = determinar_status(client, redes_sociais_guidance, client.monthly_redes_guidance_deadline_day)
#             if 'guidance_send_date' not in st.session_state or not st.session_state['guidance_send_date']:
#                 st.session_state['guidance_send_date'] = redes_sociais_guidance.send_date
#         else:
#             guidance_status = "Direcionamento n√£o encontrado"
#             st.session_state['guidance_send_date'] = None

#         # Exibir o t√≠tulo da linha do tempo
#         next_month = (datetime.now().replace(day=28) + timedelta(days=4)).strftime('%B')
#         title = f"Direcionamento Redes Sociais: {next_month.capitalize()}"
#         st.write(f"**{title}**")

#         # Definir datas importantes
#         today = datetime.today()
#         deadline_date = datetime(today.year, today.month, client.monthly_redes_guidance_deadline_day)

#         # Renderizar a linha do tempo
#         render_timeline_chart(today, deadline_date, st.session_state['guidance_send_date'])


# guidance_status - __init__.py



# guidance_status - guidance_modal.py

# import streamlit as st
# from datetime import datetime
# from streamlit_modal import Modal
# from common.models import RedesSociaisGuidance
# from page_entregas.utils.assessoria_plan_utils import salvar_data_envio, determinar_status
# import logging



# # Fun√ß√£o para exibir o modal de envio do direcionamento
# def display_guidance_modal(cliente_id):
#     # Inicializa o modal com t√≠tulo
#     modal = Modal("Data de Envio do Direcionamento", key="enviar-direcionamento-modal", max_width=800)

#     # Verifica se o modal foi solicitado (se o bot√£o foi clicado)
#     if st.button("Enviar Direcionamento"):
#         logging.info(f"Usu√°rio clicou no bot√£o 'Enviar Direcionamento' para o cliente ID {cliente_id}")
#         modal.open()

#     # Verifica se o modal est√° aberto
#     if modal.is_open():
#         logging.info(f"Modal 'Data de Envio do Direcionamento' foi aberto para o cliente ID {cliente_id}")
        
#         # Conte√∫do do modal
#         with modal.container():
#             # Input para sele√ß√£o da data de envio
#             selected_date = st.date_input("Selecione a Data de Envio", value=datetime.today())
            
#             # Bot√£o para confirmar a data selecionada
#             if st.button("Confirmar"):
#                 logging.info(f"Tentando salvar a data de envio do direcionamento para o cliente ID {cliente_id}")
                
#                 # Salvar a data de envio no banco de dados
#                 salvar_data_envio(cliente_id, selected_date, RedesSociaisGuidance, determinar_status)
                
#                 # Atualiza a sess√£o com a nova data
#                 st.session_state['guidance_send_date'] = selected_date
#                 modal.close()  # Fecha o modal
#                 st.success("Data de envio do direcionamento atualizada com sucesso!")
#                 st.rerun()  # Recarrega a p√°gina para refletir as mudan√ßas


# content_production - content_production_gauge_modals .py

import streamlit as st
from streamlit_modal import Modal
from sqlalchemy.orm import Session
import logging
from common.models import  DeliveryControl
from datetime import datetime

def edit_content_production_meeting(engine, item_id, modal):
    if modal.is_open():
        with Session(bind=engine) as session:
            content_production_meeting = session.query(DeliveryControl).get(item_id)

            if content_production_meeting is None:
                st.error("Reuni√£o de Produ√ß√£o de Conte√∫do n√£o encontrada.")
                modal.close()
                return

            # Exibir o conte√∫do do modal
            with modal.container():
                st.write("### Editar Reuni√£o de Produ√ß√£o de Conte√∫do")

                # Exibir o formul√°rio dentro do modal
                with st.form(key=f'edit_form_{item_id}'):
                    selected_date = st.date_input("Selecione a Data da Reuni√£o", value=content_production_meeting.date)
                    subject = st.text_area("Tema da Reuni√£o", value=content_production_meeting.subject)
                    meeting_notes = st.text_area("Notas", value=content_production_meeting.notes)
                    submit_edit = st.form_submit_button(label='Salvar Altera√ß√µes')

                    if submit_edit:
                        if subject:
                            try:
                                content_production_meeting.date = selected_date
                                content_production_meeting.subject = subject
                                content_production_meeting.notes = meeting_notes
                                session.commit()
                                st.success("Reuni√£o atualizada com sucesso!")
                                modal.close()  # Fechar o modal
                                st.rerun()
                            except Exception as e:
                                st.error(f"Erro ao atualizar a Reuni√£o de Produ√ß√£o de Conte√∫do: {e}")
                                logging.error(f"Erro ao atualizar reuni√£o de produ√ß√£o de conte√∫do: {e}")
                        else:
                            st.error("A descri√ß√£o da reuni√£o n√£o pode estar vazia.")
    else:
        modal.close()

def delete_content_production_meeting_meeting_modal(engine, item_id, modal):
    if modal.is_open():
        with Session(bind=engine) as session:
            content_production_meeting = session.query(DeliveryControl).get(item_id)

            if content_production_meeting is None:
                st.error("Reuni√£o n√£o encontrada.")
                modal.close()
                return

            # Exibir o conte√∫do do modal
            with modal.container():
                st.write("### Excluir Reuni√£o de Produ√ß√£o de Conte√∫do")
                st.warning(f"Tem certeza que deseja excluir a Reuni√£o de Produ√ß√£o de Conte√∫do do dia {content_production_meeting.date.strftime('%d %b. %Y')}? Esta a√ß√£o n√£o pode ser desfeita.")

                # Bot√µes de confirma√ß√£o e cancelamento
                col1, col2 = st.columns(2)
                with col1:
                    confirm_delete = st.button("Excluir", key=f'confirm_delete_meeting{item_id}')
                with col2:
                    cancel_delete = st.button("Cancelar", key=f'cancel_delete_meeting{item_id}')

                if confirm_delete:
                    try:
                        session.delete(content_production_meeting)
                        session.commit()
                        st.success("Reuni√£o exclu√≠da com sucesso!")
                        modal.close()
                        st.rerun()
                    except Exception as e:
                        st.error(f"Erro ao excluir a Reuni√£o de Produ√ß√£o de Conte√∫do: {e}")
                        logging.error(f"Erro ao excluir a Reuni√£o de Produ√ß√£o de Conte√∫do: {e}")
                elif cancel_delete:
                    modal.close()
                    st.rerun()
    else:
        modal.close()

def add_content_production_meeting_meeting_modal(engine):
    # Inicializa o modal para adicionar Reuni√£o de Produ√ß√£o de Conte√∫do
    modal = Modal("Adicionar Nova Reuni√£o de Produ√ß√£o de Conte√∫do", key="adicionar_reuni√£o_conteudo", padding=20, max_width=744)

    # Bot√£o para abrir o modal
    if st.button("Adicionar Reuni√£o de Conte√∫do"):
        modal.open()

    # Exibir o modal se estiver aberto
    if modal.is_open():
        with modal.container():
            st.write("### Nova Reuni√£o de Produ√ß√£o de Conte√∫do")
            with st.form(key='new_content_production_meeting_form'):
                selected_date = st.date_input("Selecione a Data do Reuni√£o de Produ√ß√£o de Conte√∫do", value=datetime.today())
                subject = st.text_area("Assunto da Reuni√£o de Produ√ß√£o de Conte√∫do")
                meeting_notes = st.text_area("Notas da Reuni√£o")
                submit_new = st.form_submit_button(label='Salvar')

                if submit_new:
                    if subject:
                        save_new_content_production_meeting_meeting(st.session_state["cliente_id"], selected_date, subject, meeting_notes, engine)
                        st.success("Reuni√£o adicionada com sucesso!")
                        modal.close()
                        st.rerun()
                    else:
                        st.error("A descri√ß√£o da Reuni√£o de Produ√ß√£o de Conte√∫do n√£o pode estar vazia.")

def save_new_content_production_meeting_meeting(cliente_id, production_date, subject, notes, engine):
    try:
        if engine is None:
            raise ValueError("Engine n√£o foi fornecido")
        with Session(bind=engine) as session:
            new_entry = DeliveryControl(
                client_id=cliente_id,
                date=production_date,
                subject=subject,
                notes=notes
            )
            session.add(new_entry)
            session.commit()  # Commit da nova entrada
            st.success("Reuni√£o de produ√ß√£o de conte√∫do salva com sucesso!")
    except Exception as e:
        st.error(f"Erro ao salvar a reuni√£o de produ√ß√£o de conte√∫do: {e}")

        # Log de erro detalhado
        logging.error(f"Erro ao salvar a reuni√£o de produ√ß√£o de conte√∫do: {e}")
        st.error(f"Erro ao salvar a reuni√£o de produ√ß√£o de conte√∫do: {e}")

# content_production - content_production_table_modals.py

import streamlit as st
from streamlit_modal import Modal
from sqlalchemy.orm import Session
import logging
from common.models import ContentProduction
from datetime import datetime

def edit_content_production_meeting_modal(engine, item_id, modal):
    if modal.is_open():
        with Session(bind=engine) as session:
            content_production = session.query(ContentProduction).get(item_id)

            if content_production is None:
                st.error("Reuni√£o de Produ√ß√£o de Conte√∫do n√£o encontrada.")
                modal.close()
                return

            # Exibir o conte√∫do do modal
            with modal.container():
                st.write("### Editar Reuni√£o de Produ√ß√£o de Conte√∫do")

                # Exibir o formul√°rio dentro do modal
                with st.form(key=f'edit_form_{item_id}'):
                    selected_date = st.date_input("Selecione a Data da Reuni√£o", value=content_production.date)
                    subject = st.text_area("Tema da Reuni√£o", value=content_production.subject)
                    meeting_notes = st.text_area("Notas", value=content_production.notes)
                    submit_edit = st.form_submit_button(label='Salvar Altera√ß√µes')

                    if submit_edit:
                        if subject:
                            try:
                                content_production.date = selected_date
                                content_production.subject = subject
                                content_production.notes = meeting_notes
                                session.commit()
                                st.success("Reuni√£o atualizada com sucesso!")
                                modal.close()  # Fechar o modal
                                st.rerun()
                            except Exception as e:
                                st.error(f"Erro ao atualizar a Reuni√£o de Produ√ß√£o de Conte√∫do: {e}")
                                logging.error(f"Erro ao atualizar reuni√£o de produ√ß√£o de conte√∫do: {e}")
                        else:
                            st.error("A descri√ß√£o da reuni√£o n√£o pode estar vazia.")
    else:
        modal.close()

def delete_content_production_meeting_modal(engine, item_id, modal):
    if modal.is_open():
        with Session(bind=engine) as session:
            content_production = session.query(ContentProduction).get(item_id)

            if content_production is None:
                st.error("Reuni√£o n√£o encontrada.")
                modal.close()
                return

            # Exibir o conte√∫do do modal
            with modal.container():
                st.write("### Excluir Reuni√£o de Produ√ß√£o de Conte√∫do")
                st.warning(f"Tem certeza que deseja excluir a Reuni√£o de Produ√ß√£o de Conte√∫do do dia {content_production.date.strftime('%d %b. %Y')}? Esta a√ß√£o n√£o pode ser desfeita.")

                # Bot√µes de confirma√ß√£o e cancelamento
                col1, col2 = st.columns(2)
                with col1:
                    confirm_delete = st.button("Excluir", key=f'confirm_delete_meeting{item_id}')
                with col2:
                    cancel_delete = st.button("Cancelar", key=f'cancel_delete_meeting{item_id}')

                if confirm_delete:
                    try:
                        session.delete(content_production)
                        session.commit()
                        st.success("Reuni√£o exclu√≠da com sucesso!")
                        modal.close()
                        st.rerun()
                    except Exception as e:
                        st.error(f"Erro ao excluir a Reuni√£o de Produ√ß√£o de Conte√∫do: {e}")
                        logging.error(f"Erro ao excluir a Reuni√£o de Produ√ß√£o de Conte√∫do: {e}")
                elif cancel_delete:
                    modal.close()
                    st.rerun()
    else:
        modal.close()

def add_content_production_meeting_modal(engine):
    # Inicializa o modal para adicionar Reuni√£o de Produ√ß√£o de Conte√∫do
    modal = Modal("Adicionar Nova Reuni√£o de Produ√ß√£o de Conte√∫do", key="adicionar_reuni√£o_conteudo", padding=20, max_width=744)

    # Bot√£o para abrir o modal
    if st.button("Adicionar Reuni√£o de Conte√∫do"):
        modal.open()

    # Exibir o modal se estiver aberto
    if modal.is_open():
        with modal.container():
            st.write("### Nova Reuni√£o de Produ√ß√£o de Conte√∫do")
            with st.form(key='new_content_production_form'):
                selected_date = st.date_input("Selecione a Data do Reuni√£o de Produ√ß√£o de Conte√∫do", value=datetime.today())
                subject = st.text_area("Assunto da Reuni√£o de Produ√ß√£o de Conte√∫do")
                meeting_notes = st.text_area("Notas da Reuni√£o")
                submit_new = st.form_submit_button(label='Salvar')

                if submit_new:
                    if subject:
                        save_new_content_production_meeting(st.session_state["cliente_id"], selected_date, subject, meeting_notes, engine)
                        st.success("Reuni√£o adicionada com sucesso!")
                        modal.close()
                        st.rerun()
                    else:
                        st.error("A descri√ß√£o da Reuni√£o de Produ√ß√£o de Conte√∫do n√£o pode estar vazia.")

def save_new_content_production_meeting(cliente_id, production_date, subject, notes, engine):
    try:
        if engine is None:
            raise ValueError("Engine n√£o foi fornecido")
        with Session(bind=engine) as session:
            new_entry = ContentProduction(
                client_id=cliente_id,
                date=production_date,
                subject=subject,
                notes=notes
            )
            session.add(new_entry)
            session.commit()  # Commit da nova entrada
            st.success("Reuni√£o de produ√ß√£o de conte√∫do salva com sucesso!")
    except Exception as e:
        st.error(f"Erro ao salvar a reuni√£o de produ√ß√£o de conte√∫do: {e}")

        # Log de erro detalhado
        logging.error(f"Erro ao salvar a reuni√£o de produ√ß√£o de conte√∫do: {e}")
        st.error(f"Erro ao salvar a reuni√£o de produ√ß√£o de conte√∫do: {e}")

# content_production - __init__.py



# content_production - content_production_gauge.py

import streamlit as st
from streamlit_extras.stylable_container import stylable_container
from page_entregas.utils.gauge import display_gauge_chart
from common.models import DeliveryCategoryEnum

def display_content_production_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
    """
    Exibe o gauge (gr√°fico de medidor) para produ√ß√£o de conte√∫do.
    """
    st.write("**Produ√ß√£o de Conte√∫do**")
    
    with stylable_container(key="content_production_gauge", 
                            css_styles="""
                            {
                                border: 1px solid #d3d3d3;
                                border-radius: 10px;
                                padding: 15px;
                                margin-bottom: 45px;
                            }
                            """):
        # Obter os valores espec√≠ficos para a categoria de Produ√ß√£o de Conte√∫do
        contracted = mandalecas_contratadas.get(DeliveryCategoryEnum.CONTENT_PRODUCTION, 0)
        used = mandalecas_usadas.get(DeliveryCategoryEnum.CONTENT_PRODUCTION, 0)
        accumulated = mandalecas_acumuladas.get(DeliveryCategoryEnum.CONTENT_PRODUCTION, 0)

        # Exibir o gr√°fico de gauge
        display_gauge_chart(
            title="Produ√ß√£o de Conte√∫do",
            contracted=contracted,
            used=used,
            accumulated=accumulated
        )


# content_production - content_production_table.py

import streamlit as st
from sqlalchemy.orm import Session
import pandas as pd
from common.models import ContentProduction
import logging
from page_entregas.utils.styles import css_tabela
from page_entregas.content_production.content_production_table_modals import (
    edit_content_production_meeting_modal,
    delete_content_production_meeting_modal,
    add_content_production_meeting_modal
)
from streamlit_modal import Modal
from streamlit_extras.stylable_container import stylable_container

# Configura√ß√£o do logging
logging.basicConfig(
    filename='logs/content_production.log',  # Nome do arquivo onde os logs ser√£o salvos
    level=logging.ERROR,  # N√≠vel do log (ERROR para registrar erros)
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)


def display_content_production_table(cliente_id, data_inicio, data_fim, engine):
    """
    Exibe a tabela de reuni√µes de produ√ß√£o de conte√∫do para um cliente, em um intervalo de datas,
    com bot√µes de Editar e Excluir, encapsulada em um container estilizado.
    """
    try:
        # Iniciar uma sess√£o do SQLAlchemy para buscar as reuni√µes de produ√ß√£o de conte√∫do
        with Session(bind=engine) as session:
            content_production = session.query(ContentProduction).filter(
                ContentProduction.client_id == cliente_id,
                ContentProduction.date.between(data_inicio, data_fim)
            ).order_by(ContentProduction.date.desc()).all()

        # Verificar se h√° reuni√µes de produ√ß√£o de conte√∫do
        if not content_production:
            st.info("Nenhuma reuni√£o de produ√ß√£o de conte√∫do encontrada para o per√≠odo selecionado.")
        else:
            # Criar uma lista de dicion√°rios para armazenar as reuni√µes
            data = []
            for cp in content_production:
                data.append({
                    'Data': cp.date.strftime('%d %b. %Y') if cp.date else '',
                    'Tema da Reuni√£o': cp.subject,
                    'Notas': cp.notes if cp.notes else '-',
                    'ID': cp.id
                })

            # Converter os dados em DataFrame para facilitar a exibi√ß√£o
            content_production_df = pd.DataFrame(data)

            st.write("**Reuni√µes de Produ√ß√£o de Conte√∫do**")

            # Inicializar os modais fora de qualquer container ou loop
            edit_modal = Modal("Editar Reuni√£o", key="edit_modal_cp", max_width=800)
            delete_modal = Modal("Excluir Reuni√£o", key="delete_modal_cp", max_width=800)

            # Exibir a tabela dentro do container estilizado
            with stylable_container(
                key="tabela_content_production",
                css_styles=css_tabela()
            ):
                # Criar cabe√ßalho da tabela
                header_cols = st.columns([2, 5, 5, 1, 1])
                header_cols[0].write("**Data**")
                header_cols[1].write("**Tema da Reuni√£o**")
                header_cols[2].write("**Notas**")
                header_cols[3].write("**Editar**")
                header_cols[4].write("**Excluir**")

                # Exibir os dados com bot√µes de a√ß√£o
                for index, row in content_production_df.iterrows():
                    # Definir a cor de fundo com base na paridade do √≠ndice
                    row_bg_color = '#FFFFFF' if index % 2 == 0 else '#F0F0F0'

                    # Aplicar o estilo √† linha usando stylable_container
                    with stylable_container(
                        key=f'row_{row["ID"]}_{index}',
                        css_styles=f'''
                        background-color: {row_bg_color};
                        padding: 5px;
                        border-radius: 5px;
                        '''
                    ):
                        cols = st.columns([2, 5, 5, 1, 1])
                        cols[0].write(row['Data'])
                        cols[1].write(row['Tema da Reuni√£o'])
                        cols[2].write(row['Notas'])
                        if cols[3].button('‚úèÔ∏è', key=f'edit_{row["ID"]}_{index}', help='Editar'):
                            st.session_state['edit_item_id'] = row['ID']
                            edit_modal.open()
                        if cols[4].button('üóëÔ∏è', key=f'delete_{row["ID"]}_{index}', help='Excluir'):
                            st.session_state['delete_item_id'] = row['ID']
                            delete_modal.open()

            # Chamar as fun√ß√µes dos modais fora do container e de qualquer loop
            if edit_modal.is_open():
                edit_content_production_meeting_modal(engine, st.session_state['edit_item_id'], edit_modal)

            if delete_modal.is_open():
                delete_content_production_meeting_modal(engine, st.session_state['delete_item_id'], delete_modal)

        # Bot√£o para adicionar nova reuni√£o
        add_content_production_meeting_modal(engine)

    except Exception as e:
        # Adicionar logging para erros inesperados
        logging.error(f"Erro ao exibir a tabela de produ√ß√£o de conte√∫do: {e}")
        st.error("Ocorreu um erro ao carregar os dados de produ√ß√£o de conte√∫do. Por favor, tente novamente mais tarde.")




