# . - mandalecas bkp.py

from datetime import datetime
from common.models import DeliveryCategoryEnum, Client, DeliveryControl
from sqlalchemy.orm import Session
from sqlalchemy.sql import func
import streamlit as st  

def calcular_mandalecas(cliente_id: int, data_inicio: datetime, data_fim: datetime, session: Session):
    """
    Calcula as mandalecas contratadas, usadas e acumuladas para um cliente específico.

    Parâmetros:
    - cliente_id (int): ID do cliente.
    - data_inicio (datetime): Data de início do período.
    - data_fim (datetime): Data de fim do período.
    - session (Session): Sessão do SQLAlchemy.

    Retorna:
    - mandalecas_contratadas (dict): Mandalecas contratadas por categoria.
    - mandalecas_usadas (dict): Mandalecas usadas por categoria.
    - mandalecas_acumuladas (dict): Mandalecas acumuladas por categoria.
    """

    # Obter o cliente
    cliente = session.query(Client).filter(Client.id == cliente_id).first()
    if not cliente:
        st.error(f"Cliente com ID {cliente_id} não encontrado.")
        return None, None, None

    # Mandalecas Contratadas
    mandalecas_contratadas = {
        DeliveryCategoryEnum.CONTENT_PRODUCTION: cliente.n_monthly_contracted_content_production_mandalecas or 0,
        # Adicione outras categorias conforme necessário
    }

    # Mandalecas Acumuladas
    mandalecas_acumuladas = {
        DeliveryCategoryEnum.CONTENT_PRODUCTION: cliente.accumulated_content_production_mandalecas or 0,
        # Adicione outras categorias conforme necessário
    }

    # Mandalecas Usadas no período atual
    mandalecas_usadas = {}

    # Calcular mandalecas usadas para 'Produção de Conteúdo'
    total_usadas = session.query(func.sum(DeliveryControl.used_mandalecas)).filter(
        DeliveryControl.client_id == cliente_id,
        DeliveryControl.delivery_category == DeliveryCategoryEnum.CONTENT_PRODUCTION,
        DeliveryControl.job_creation_date.between(data_inicio, data_fim)
    ).scalar() or 0

    mandalecas_usadas[DeliveryCategoryEnum.CONTENT_PRODUCTION] = total_usadas

    return mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas


# . - gauge bkp.py

import plotly.graph_objects as go
import streamlit as st

def display_gauge_chart(title, contracted, used, accumulated=0):
    """
    Função para exibir um gráfico de medidor (gauge) que mostra os valores contratados, usados e acumulados.

    :param title: Título do medidor.
    :param contracted: Valor contratado.
    :param used: Valor usado até o momento.
    :param accumulated: Valor acumulado (positivo ou negativo).
    """
    if accumulated < 0:
        # Quando o acumulado é negativo, considera um déficit
        max_value = contracted  # Mantém o max_value como o contratado quando há um déficit
        deficit_start = contracted + accumulated  # Início do déficit (valor menor que o contratado)
        steps = [
            {'range': [0, deficit_start], 'color': "lightgray"},  # Intervalo até o início do déficit
            {'range': [deficit_start, contracted], 'color': "red"}  # Intervalo do déficit
        ]
        accumulated_color = 'red'
    else:
        # Caso contrário, o acumulado é positivo
        max_value = contracted + accumulated
        steps = [
            {'range': [0, contracted], 'color': "lightgray"},
            {'range': [contracted, max_value], 'color': "orange"}
        ]
        accumulated_color = 'orange'

    # Cria o gráfico de medidor (gauge)
    fig = go.Figure(go.Indicator(
        mode="gauge+number",
        value=used,
        title={'text': title, 'font': {'size': 20}},
        number={'font': {'size': 40}},
        gauge={
            'axis': {'range': [0, max_value], 'tickwidth': 1, 'tickcolor': "darkblue"},
            'bar': {'color': "green"},
            'steps': steps,
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': contracted
            }
        }
    ))

    # Configura o layout e estilo do gráfico
    fig.update_layout(
        autosize=False,
        width=350,
        height=250,
        margin=dict(l=20, r=20, t=50, b=100),
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        annotations=[
            dict(
                x=0.15, y=-0.05, xref='paper', yref='paper',
                text=f"Contratado: {contracted}",
                showarrow=False,
                font=dict(color="white", size=12),
                xanchor='center',
                yanchor='top',
                bgcolor='green',
                borderpad=5,
                borderwidth=2,
                bordercolor='rgba(0,0,0,0)',
                opacity=1
            ),
            dict(
                x=0.8, y=-0.05, xref='paper', yref='paper',
                text=f"<b>Acumulado:</b> {accumulated}",
                showarrow=False,
                font=dict(color="white", size=12),
                xanchor='center',
                yanchor='top',
                bgcolor=accumulated_color,  # Cor de fundo dinâmica baseada no acumulado
                borderpad=5,
                borderwidth=2,
                bordercolor='rgba(0,0,0,0)',
                opacity=1
            )
        ]
    )

    # Renderiza o gráfico no Streamlit
    st.plotly_chart(fig, use_container_width=True)



# . - page_entregas.py

import streamlit as st
import pandas as pd
import logging
from sqlalchemy.orm import Session
from common.models import AttentionPoints, Client
from datetime import datetime, date, timedelta
import locale
from page_entregas.attention_points.attention_points_table import display_attention_points_table
from page_entregas.content_production.content_production_table import display_content_production_table
from page_entregas.content_production.content_production_gauge import display_content_production_gauge
from page_entregas.utils.mandalecas import calcular_mandalecas
from streamlit_extras.stylable_container import stylable_container

# Configurar a localidade para português do Brasil
try:
    locale.setlocale(locale.LC_TIME, 'pt_BR.utf8')
except locale.Error:
    locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')  # Para Windows

# Configuração de logging
logging.basicConfig(filename='debug_log.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# Configurações iniciais do Streamlit
st.set_page_config(layout="wide")

def page_entregas(engine):
    logging.debug("Entrando na função page_entregas()")

    # ===========================================================
    # Seção de Seletores de Cliente e Intervalo de Datas na Barra Lateral
    # ===========================================================

    st.sidebar.title("Filtros")

    # Obter a lista de clientes
    clientes_df = get_clientes(engine)

    # Verificar se há clientes disponíveis
    if clientes_df.empty:
        st.error("Nenhum cliente disponível.")
        return

    # Inicializar o st.session_state para data_inicio e data_fim, se necessário
    if "data_inicio" not in st.session_state:
        st.session_state["data_inicio"] = date.today() - timedelta(days=30)
    if "data_fim" not in st.session_state:
        st.session_state["data_fim"] = date.today()
    if "cliente_id" not in st.session_state:
        st.session_state["cliente_id"] = clientes_df["id"].iloc[0]

    # Criar um formulário na barra lateral para os seletores
    with st.sidebar.form(key='filters_form'):
        # Seletor de Cliente
        options = clientes_df["id"].tolist()

        # Usar st.session_state["cliente_id"] como valor inicial para manter a seleção atual
        cliente_id = st.selectbox(
            "Selecione o Cliente",
            options=options,
            index=options.index(st.session_state["cliente_id"]),
            format_func=lambda x: clientes_df[clientes_df["id"] == x]["name"].values[0],
            key="cliente_id_temp"  # Usar uma chave temporária para o seletor
        )

        # Seletor de Intervalo de Datas
        date_range = st.date_input(
            "Selecione o Intervalo de Datas",
            value=(st.session_state["data_inicio"], st.session_state["data_fim"]),
            key="date_range"
        )

        # Botão para aplicar os filtros
        submit_button = st.form_submit_button(label='Aplicar Filtros')

    # Verifica se o botão foi clicado
    if submit_button:
        # Atualizar o cliente selecionado no session_state
        st.session_state["cliente_id"] = cliente_id
        # Validar o intervalo de datas
        if isinstance(date_range, tuple) and len(date_range) == 2:
            data_inicio, data_fim = date_range
            # Atualizar o st.session_state com os valores selecionados
            st.session_state["data_inicio"] = data_inicio
            st.session_state["data_fim"] = data_fim
            logging.debug("Filtros aplicados. Reexecutando a página.")
            st.rerun()
        else:
            st.error("Por favor, selecione um intervalo de datas válido.")

    # Log dos valores selecionados
    logging.debug(f"Cliente selecionado: {st.session_state['cliente_id']}")
    logging.debug(f"Data início: {st.session_state['data_inicio']}, Data fim: {st.session_state['data_fim']}")

    # Obter o cliente selecionado e armazenar no st.session_state
    with Session(bind=engine) as session:
        cliente_selecionado = session.query(Client).filter(Client.id == st.session_state["cliente_id"]).first()
        if cliente_selecionado:
            st.session_state["cliente_obj"] = cliente_selecionado
        else:
            st.error("Cliente não encontrado.")
            return

    # Obter o nome do cliente selecionado
    cliente_nome = cliente_selecionado.name
    cliente_logo_url = cliente_selecionado.logo_url

    # Exibir o nome do cliente selecionado na página principal
    if cliente_logo_url:
        col1, col2 = st.columns([1, 5])  # Ajuste as proporções das colunas conforme necessário

        with col1:
            st.image(cliente_logo_url, width=50)  # Exibe a logo do cliente com uma largura ajustada
        with col2:
            st.write(f"## {cliente_nome}")
    else:
        st.write(f"## {cliente_nome}")

    # ===========================================================
    # Exibir Pontos de Atenção
    # ===========================================================

    display_attention_points_table(
        st.session_state["cliente_id"],
        st.session_state["data_inicio"],
        st.session_state["data_fim"],
        engine
    )

    # ===========================================================
    # Exibir Produção de Conteúdo
    # ===========================================================

    # Calcular mandalecas para o gauge de produção de conteúdo
    with Session(bind=engine) as session:
        mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas = calcular_mandalecas(
            st.session_state["cliente_obj"],
            st.session_state["data_inicio"],
            st.session_state["data_fim"],
            session
        )

    # Criar colunas para o gauge e a tabela
    col_gauge, col_table = st.columns([0.3, 0.7])

    with col_gauge:
        # Exibir o gauge de Produção de Conteúdo
        display_content_production_gauge(
            mandalecas_contratadas,
            mandalecas_usadas,
            mandalecas_acumuladas
        )

    with col_table:
        # Exibir a tabela de Produção de Conteúdo
        display_content_production_table(
            st.session_state["cliente_id"],
            st.session_state["data_inicio"],
            st.session_state["data_fim"],
            engine
        )

# Função para obter a lista de clientes do banco de dados
def get_clientes(engine):
    with Session(bind=engine) as session:
        clientes = session.query(Client).all()
        clientes_df = pd.DataFrame([{'id': c.id, 'name': c.name, 'logo_url': c.logo_url} for c in clientes])
    return clientes_df

# ===========================================================
# Função principal para executar a página
# ===========================================================
if __name__ == "__main__":
    from common.database import create_engine_and_session
    engine = create_engine_and_session()

    # Executar a função principal
    page_entregas(engine)


# blog_text - blog_gauge.py

import streamlit as st
from plotly.graph_objects import Figure
from streamlit_extras.stylable_container import stylable_container
from page_entregas.utils.gauge import display_gauge_chart

# ===========================================================
# Funções para Exibição do Gauge de Texto de Blog
# ===========================================================

def display_blog_text_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
    """
    Exibe o gauge (gráfico de medidor) de uso de mandalecas para texto de blog.
    """
    st.write("**Texto de Blog**")

    with stylable_container(key="blog_text_gauge", 
                            css_styles="""
                            {
                                border: 1px solid #d3d3d3;
                                border-radius: 10px;
                                padding: 15px;
                                margin-bottom: 45px;
                            }
                            """):
        # Exibir o gráfico de gauge para o texto de blog
        gauge_chart = display_gauge_chart(
            title="Texto de Blog",
            contracted=mandalecas_contratadas.get('BlogText', 0),
            used=mandalecas_usadas.get('BlogText', 0),
            accumulated=mandalecas_acumuladas.get('BlogText', 0)
        )
        st.plotly_chart(gauge_chart)



# blog_text - __init__.py



# attention_points - attention_points_table.py

import streamlit as st
from streamlit_extras.stylable_container import stylable_container
import pandas as pd
from sqlalchemy.orm import Session
from common.models import AttentionPoints  # Verifique se o caminho está correto
import logging
from page_entregas.attention_points.attention_points_crud_modals import edit_attention_point_modal, delete_attention_point_modal, add_attention_point_modal


def display_attention_points_table(cliente_id, data_inicio, data_fim, engine):
    """
    Exibe a tabela de pontos de atenção para um cliente, em um intervalo de datas,
    com botões de Editar e Excluir, encapsulada em um container estilizado.
    """
    try:
        with Session(bind=engine) as session:
            attention_points = session.query(AttentionPoints).filter(
                AttentionPoints.client_id == cliente_id,
                AttentionPoints.date.between(data_inicio, data_fim)
            ).order_by(AttentionPoints.date.desc()).all()

        if not attention_points:
            st.info("Nenhum ponto de atenção encontrado para o período selecionado.")
        else:
            data = []
            for ap in attention_points:
                data.append({
                    'Data': ap.date.strftime('%d %b. %Y'),
                    'Ponto de Atenção': ap.attention_point,
                    'ID': ap.id
                })

            attention_points_df = pd.DataFrame(data)

            # Definir o CSS para o container apenas da tabela
            css_tabela = """
            {
                border: 1px dashed lightgray;
                border-radius: 10px;
                padding: 15px;
                margin-top: 10px;
                background-color: white;
            }
            """

            # Encapsular a tabela e os botões de ação no container estilizado
            with stylable_container(
                key="tabela_attention_points",
                css_styles=css_tabela
            ):
                st.write("**Pontos de Atenção**")
                # Exibir a tabela com botões de ação
                for index, row in attention_points_df.iterrows():
                    col1, col2, col3, col4 = st.columns([2, 7, 1, 1])
                    col1.write(row['Data'])
                    col2.write(row['Ponto de Atenção'])
                    if col3.button('✏️', key=f'edit_{row["ID"]}', help='Editar'):
                        st.session_state['edit_item_id'] = row['ID']
                        st.session_state['edit_modal_open'] = True  # Abrir modal de edição
                    if col4.button('🗑️', key=f'delete_{row["ID"]}', help='Excluir'):
                        st.session_state['delete_item_id'] = row['ID']
                        st.session_state['delete_modal_open'] = True  # Abrir modal de exclusão
        add_attention_point_modal(engine)

        # Processar edição - abrir o modal ao clicar no botão de editar
        if st.session_state.get('edit_modal_open'):
            edit_attention_point_modal(engine, st.session_state['edit_item_id'])

        # Processar exclusão - abrir o modal ao clicar no botão de excluir
        if st.session_state.get('delete_modal_open'):
            delete_attention_point_modal(engine, st.session_state['delete_item_id'])

    except Exception as e:
        st.error(f"Erro ao carregar pontos de atenção: {e}")
        logging.error(f"Erro ao carregar pontos de atenção: {e}")
    


# attention_points - __init__.py



# attention_points - attention_points_crud_modals.py

import streamlit as st
from streamlit_modal import Modal
from sqlalchemy.orm import Session
import logging
from common.models import AttentionPoints
from datetime import datetime

def edit_attention_point_modal(engine, item_id):
    # Criar e configurar o modal
    modal = Modal("Editar Ponto de Atenção", key=f'edit_modal_{item_id}', padding=20, max_width=744)

    # Verificar se o modal está aberto
    st.write(f"Modal aberto: {st.session_state.get('edit_modal_open', False)}")

    if st.session_state.get('edit_modal_open', False):
        with Session(bind=engine) as session:
            attention_point = session.query(AttentionPoints).get(item_id)

            if attention_point is None:
                st.error("Ponto de atenção não encontrado.")
                st.session_state['edit_modal_open'] = False  # Fechar o modal
                return

            # Exibir o formulário para depuração (fora do modal temporariamente)
            with st.form(key=f'edit_form_{item_id}'):
                selected_date = st.date_input("Selecione a Data do Ponto de Atenção", value=attention_point.date)
                attention_description = st.text_area("Descrição do Ponto de Atenção", value=attention_point.attention_point)
                submit_edit = st.form_submit_button(label='Salvar Alterações')

                # Verificar se o botão foi clicado
                if submit_edit:
                    st.write('Detectei o clique no botão')

                    if attention_description:
                        try:
                            attention_point.date = selected_date
                            attention_point.attention_point = attention_description
                            session.commit()
                            st.success("Ponto de atenção atualizado com sucesso!")
                            st.session_state['edit_item_id'] = None
                            st.session_state['edit_modal_open'] = False
                            st.rerun()
                        except Exception as e:
                            st.error(f"Erro ao atualizar o ponto de atenção: {e}")
                    else:
                        st.error("A descrição do ponto de atenção não pode estar vazia.")


def delete_attention_point_modal(engine, item_id):
    """
    Exibe o modal de confirmação de exclusão do ponto de atenção.
    """
    modal = Modal("Excluir Ponto de Atenção", key=f'delete_modal_{item_id}', padding=20, max_width=744)

    # Abrir o modal se o botão de exclusão foi clicado
    if st.session_state.get('delete_modal_open', False):
        with Session(bind=engine) as session:
            attention_point = session.query(AttentionPoints).get(item_id)

            if attention_point is None:
                st.error("Ponto de atenção não encontrado.")
                st.session_state['delete_modal_open'] = False  # Fechar o modal se o item não for encontrado
                return

            # Exibir o conteúdo do modal
            with modal.container():
                st.write("### Excluir Ponto de Atenção")
                st.warning(f"Tem certeza que deseja excluir o ponto de atenção do dia {attention_point.date.strftime('%d %b. %Y')}? Esta ação não pode ser desfeita.")

                # Botões de confirmação e cancelamento
                col1, col2 = st.columns(2)
                with col1:
                    confirm_delete = st.button("Excluir", key=f'confirm_delete_{item_id}')
                with col2:
                    cancel_delete = st.button("Cancelar", key=f'cancel_delete_{item_id}')

                # Processar exclusão
                if confirm_delete:
                    try:
                        session.delete(attention_point)  # Deletar o ponto
                        session.commit()  # Commit da exclusão
                        st.success("Ponto de atenção excluído com sucesso!")
                        st.session_state['delete_item_id'] = None  # Resetar o estado após exclusão
                        st.session_state['delete_modal_open'] = False  # Fechar o modal
                        st.rerun()  # Recarregar a página
                    except Exception as e:
                        st.error(f"Erro ao excluir o ponto de atenção: {e}")
                elif cancel_delete:
                    st.session_state['delete_modal_open'] = False  # Fechar o modal se o usuário cancelar
                    st.rerun()

# Função para adicionar um novo ponto de atenção utilizando streamlit-modal
def add_attention_point_modal(engine):
    # Passo 3: Definir o modal
    modal = Modal("Adicionar Novo Ponto de Atenção", key="adicionar_ponto_modal", padding=20, max_width=744)

    # Passo 4: Botão para abrir o modal
    if st.button("Adicionar Ponto de Atenção"):
        modal.open()

    # Passo 5: Exibir o modal se estiver aberto
    if modal.is_open():
        with modal.container():
            st.write("### Novo Ponto de Atenção")
            # Passo 6: Exibir o formulário dentro do modal
            with st.form(key='new_attention_point_form'):
                selected_date = st.date_input("Selecione a Data do Ponto de Atenção", value=datetime.today())
                attention_description = st.text_area("Descrição do Ponto de Atenção")
                submit_new = st.form_submit_button(label='Salvar')

                # Manipulação da submissão
                if submit_new:
                    if attention_description:  # Verifica se a descrição não está vazia
                        save_new_attention_point(st.session_state["cliente_id"], selected_date, attention_description, engine)
                        st.success("Ponto de atenção adicionado com sucesso!")
                        modal.close()  # Fechar o modal
                        st.rerun()  # Recarregar a página
                    else:
                        st.error("A descrição do ponto de atenção não pode estar vazia.")

# Função para salvar o novo ponto de atenção no banco de dados
def save_new_attention_point(cliente_id, attention_date, attention_point, engine):
    try:
        with Session(bind=engine) as session:
            new_entry = AttentionPoints(
                client_id=cliente_id,
                date=attention_date,
                attention_point=attention_point
            )
            session.add(new_entry)
            session.commit()  # Commit da nova entrada
            st.success("Ponto de atenção salvo com sucesso!")
    except Exception as e:
        st.error(f"Erro ao salvar o ponto de atenção: {e}")


# paid_traffic - __init__.py



# paid_traffic - traffic_gauge.py

# import streamlit as st
# from page_entregas.utils.gauge import display_gauge_chart
# from common.models import JobCategoryEnum

# # Função para exibir os gráficos de gauge de tráfego pago
# def display_traffic_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
#     st.write("**Tráfego Pago**")
    
#     with st.container():
#         # Criar colunas internas para os gráficos de tráfego pago
#         col1, col2 = st.columns(2)

#         # Gauge para Tráfego Pago Estático
#         with col1:
#             gauge_chart_static = display_gauge_chart(
#                 title="Tráfego Pago (Estático)",
#                 contracted=mandalecas_contratadas.get(JobCategoryEnum.STATIC_TRAFEGO_PAGO, 0),
#                 used=mandalecas_usadas.get(JobCategoryEnum.STATIC_TRAFEGO_PAGO, 0),
#                 accumulated=mandalecas_acumuladas.get(JobCategoryEnum.STATIC_TRAFEGO_PAGO, 0)
#             )
#             st.plotly_chart(gauge_chart_static, use_container_width=True)

#         # Gauge para Tráfego Pago Animado
#         with col2:
#             gauge_chart_animated = display_gauge_chart(
#                 title="Tráfego Pago (Animado)",
#                 contracted=mandalecas_contratadas.get(JobCategoryEnum.ANIMATED_TRAFEGO_PAGO, 0),
#                 used=mandalecas_usadas.get(JobCategoryEnum.ANIMATED_TRAFEGO_PAGO, 0),
#                 accumulated=mandalecas_acumuladas.get(JobCategoryEnum.ANIMATED_TRAFEGO_PAGO, 0)
#             )
#             st.plotly_chart(gauge_chart_animated, use_container_width=True)


# creation_and_adaptation - adaptation_gauge.py

# import streamlit as st
# from plotly.graph_objects import Figure
# from common.models import JobCategoryEnum
# from page_entregas.utils.gauge import display_gauge_chart


# # Função para exibir o gráfico de Adaptação
# def display_adaptation_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
#     st.write("**Adaptação de Formato**")
    
#     # Container estilizado para o gráfico gauge
#     with st.container():
#         # Obter dados de mandalecas contratadas, usadas e acumuladas para adaptação de formato
#         contracted = mandalecas_contratadas.get(JobCategoryEnum.ADAPTACAO, 0)
#         used = mandalecas_usadas.get(JobCategoryEnum.ADAPTACAO, 0)
#         accumulated = mandalecas_acumuladas.get(JobCategoryEnum.ADAPTACAO, 0)

#         # Gerar o gráfico gauge de adaptação usando a função utilitária
#         gauge_chart = display_gauge_chart(
#             title="Adaptação de Formato",
#             contracted=contracted,
#             used=used,
#             accumulated=accumulated
#         )

#         # Exibir o gráfico
#         st.plotly_chart(gauge_chart, use_container_width=True)


# creation_and_adaptation - __init__.py



# creation_and_adaptation - creation_gauge.py

# import streamlit as st
# from plotly.graph_objects import Figure
# from common.models import JobCategoryEnum
# from page_entregas.utils.gauge import display_gauge_chart


# # Função para exibir o gráfico de Criação
# def display_creation_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
#     st.write("**Criação**")
    
#     # Container estilizado para o gráfico gauge
#     with st.container():
#         # Obter dados de mandalecas contratadas, usadas e acumuladas para criação
#         contracted = mandalecas_contratadas.get(JobCategoryEnum.CRIACAO, 0)
#         used = mandalecas_usadas.get(JobCategoryEnum.CRIACAO, 0)
#         accumulated = mandalecas_acumuladas.get(JobCategoryEnum.CRIACAO, 0)

#         # Gerar o gráfico gauge de criação usando a função utilitária
#         gauge_chart = display_gauge_chart(
#             title="Criação",
#             contracted=contracted,
#             used=used,
#             accumulated=accumulated
#         )

#         # Exibir o gráfico
#         st.plotly_chart(gauge_chart, use_container_width=True)


# social_media - social_media_gauges.py

# import streamlit as st
# from page_entregas.utils.gauge import display_gauge_chart
# from common.models import JobCategoryEnum
# from streamlit_extras.stylable_container import stylable_container
# import plotly.graph_objects as go  # Importação para criar gráficos com Plotly


# # Função para exibir o medidor do Instagram
# def display_instagram_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
#     st.write("**Instagram**")
#     with stylable_container(key="instagram_gauge", 
#                             css_styles="""
#                             {
#                                 border: 1px solid #d3d3d3;
#                                 border-radius: 10px;
#                                 padding: 15px;
#                                 margin-bottom: 45px;
#                             }
#                             """):
#         gauge_chart = display_gauge_chart(
#             title="Instagram",
#             contracted=mandalecas_contratadas.get(JobCategoryEnum.FEED_INSTAGRAM, 0),
#             used=mandalecas_usadas.get(JobCategoryEnum.FEED_INSTAGRAM, 0),
#             accumulated=mandalecas_acumuladas.get(JobCategoryEnum.FEED_INSTAGRAM, 0)
#         )
#         st.plotly_chart(gauge_chart)

#         # Distribuição do uso de conteúdo no Instagram
#         social_media_data = {
#             "Carrossel Instagram": mandalecas_usadas.get(JobCategoryEnum.CAROUSEL_INSTAGRAM, 0),
#             "Reels Instagram": mandalecas_usadas.get(JobCategoryEnum.REELS_INSTAGRAM, 0),
#             "Card Instagram": mandalecas_usadas.get(JobCategoryEnum.CARD_INSTAGRAM, 0)
#         }

#         pie_chart = create_pie_chart(social_media_data, "Distribuição Instagram")
#         st.plotly_chart(pie_chart)


# # Função para exibir o medidor de outras redes (LinkedIn, TikTok)
# def display_other_networks_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
#     st.write("**Outras Redes**")
#     with stylable_container(key="other_networks_gauge", 
#                             css_styles="""
#                             {
#                                 border: 1px solid #d3d3d3;
#                                 border-radius: 10px;
#                                 padding: 15px;
#                                 margin-bottom: 45px;
#                             }
#                             """):
#         linkedin_gauge = display_gauge_chart(
#             title="Feed LinkedIn",
#             contracted=mandalecas_contratadas.get(JobCategoryEnum.FEED_LINKEDIN, 0),
#             used=mandalecas_usadas.get(JobCategoryEnum.FEED_LINKEDIN, 0),
#             accumulated=mandalecas_acumuladas.get(JobCategoryEnum.FEED_LINKEDIN, 0)
#         )
#         st.plotly_chart(linkedin_gauge)

#         tiktok_gauge = display_gauge_chart(
#             title="Feed TikTok",
#             contracted=mandalecas_contratadas.get(JobCategoryEnum.FEED_TIKTOK, 0),
#             used=mandalecas_usadas.get(JobCategoryEnum.FEED_TIKTOK, 0),
#             accumulated=mandalecas_acumuladas.get(JobCategoryEnum.FEED_TIKTOK, 0)
#         )
#         st.plotly_chart(tiktok_gauge)


# def create_pie_chart(data, title):
#     labels = list(data.keys())
#     values = list(data.values())
#     fig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=.3)])
#     fig.update_layout(title_text=title)
#     return fig

# social_media - __init__.py



# website_maintenance - website_gauge_timeline.py

# import streamlit as st
# from page_entregas.utils.gauge import display_gauge_chart
# from page_entregas.utils.timeline import render_timeline_chart_with_multiple_events
# from common.models import JobCategoryEnum
# from streamlit_extras.stylable_container import stylable_container
# from page_entregas.website_maintenance.website_modal  import modal_website_maintenance_open
# from datetime import datetime, timedelta
# import calendar

# # Função para exibir o medidor e a linha do tempo para manutenção de websites
# def display_website_maintenance_gauge_and_timeline(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas, maintenance_dates):
#     st.write("**Manutenção de Website**")

#     # Criar colunas para o medidor e a linha do tempo
#     col1 = st.container()

#     with col1:
#         gauge_chart = display_gauge_chart(
#             title="Manutenção de Website",
#             contracted=mandalecas_contratadas.get(JobCategoryEnum.WEBSITE_MAINTENANCE, 0),
#             used=mandalecas_usadas.get(JobCategoryEnum.WEBSITE_MAINTENANCE, 0),
#             accumulated=mandalecas_acumuladas.get(JobCategoryEnum.WEBSITE_MAINTENANCE, 0)
#         )
#         st.plotly_chart(gauge_chart, use_container_width=True)

#     # Renderizar a linha do tempo de manutenção de websites
#     today = datetime.today()
#     deadline_date = today.replace(day=1) + timedelta(days=calendar.monthrange(today.year, today.month)[1] - 1)
#     render_timeline_chart_with_multiple_events(today, deadline_date, maintenance_dates)

#     # Adicionar botão para abrir o modal e adicionar uma nova data de manutenção
#     if st.button("Adicionar Data de Manutenção"):
#         modal_website_maintenance_open()


# website_maintenance - __init__.py



# website_maintenance - website_modal.py

# import streamlit as st
# from datetime import datetime
# from streamlit_modal import Modal
# from sqlalchemy.orm import Session
# from common.models import WebsiteMaintenance
# from common.database import engine
# import logging

# def modal_website_maintenance_open():
#     cliente_id = st.session_state.get("cliente_id")

#     # Inicializa o modal para adicionar manutenção de website
#     modal = Modal("Adicionar Data de Manutenção de Website", key="adicionar-manutencao-modal", max_width=800)

#     if modal.is_open():
#         with modal.container():
#             selected_date = st.date_input("Selecione a Data de Manutenção", value=datetime.today())
#             if st.button("Salvar"):
#                 save_website_maintenance_date(cliente_id, selected_date)
#                 modal.close()
#                 st.success("Data de manutenção adicionada com sucesso!")
#                 st.rerun()

# def save_website_maintenance_date(cliente_id, selected_date):
#     try:
#         with Session(bind=engine) as session:
#             new_entry = WebsiteMaintenance(
#                 client_id=cliente_id,
#                 date=selected_date
#             )
#             session.add(new_entry)
#             session.commit()
#             logging.info(f"Data de manutenção para o cliente ID {cliente_id} adicionada com sucesso.")
#     except Exception as e:
#         st.error(f"Erro ao salvar a data de manutenção: {e}")
#         logging.error(f"Erro ao salvar a data de manutenção: {e}")


# utils - mandalecas.py

from datetime import datetime
from common.models import DeliveryCategoryEnum, Client, DeliveryControl
from sqlalchemy.orm import Session
from sqlalchemy.sql import func
import streamlit as st  

def calcular_mandalecas(cliente: Client, data_inicio: datetime, data_fim: datetime, session: Session):
    """
    Calcula as mandalecas contratadas, usadas e acumuladas para um cliente específico.

    Parâmetros:
    - cliente (Client): Objeto do cliente.
    - data_inicio (datetime): Data de início do período.
    - data_fim (datetime): Data de fim do período.
    - session (Session): Sessão do SQLAlchemy.

    Retorna:
    - mandalecas_contratadas (dict): Mandalecas contratadas por categoria.
    - mandalecas_usadas (dict): Mandalecas usadas por categoria.
    - mandalecas_acumuladas (dict): Mandalecas acumuladas por categoria.
    """
    # Verificar se o cliente foi fornecido
    if not cliente:
        st.error("Cliente não fornecido.")
        return None, None, None

    # Mandalecas Contratadas
    mandalecas_contratadas = {
        DeliveryCategoryEnum.CONTENT_PRODUCTION: cliente.n_monthly_contracted_content_production_mandalecas or 0,
        # Adicione outras categorias conforme necessário
    }

    # Mandalecas Acumuladas
    mandalecas_acumuladas = {
        DeliveryCategoryEnum.CONTENT_PRODUCTION: cliente.accumulated_content_production_mandalecas or 0,
        # Adicione outras categorias conforme necessário
    }

    # Mandalecas Usadas no período atual
    mandalecas_usadas = {}

    # Calcular mandalecas usadas para 'Produção de Conteúdo'
    total_usadas = session.query(func.sum(DeliveryControl.used_mandalecas)).filter(
        DeliveryControl.client_id == cliente.id,
        DeliveryControl.delivery_category == DeliveryCategoryEnum.CONTENT_PRODUCTION,
        DeliveryControl.job_creation_date.between(data_inicio, data_fim)
    ).scalar() or 0

    mandalecas_usadas[DeliveryCategoryEnum.CONTENT_PRODUCTION] = total_usadas

    return mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas


# utils - chat_gpt.py

import os

# Caminho da pasta que você quer percorrer
caminho_projeto = '/home/debrito/Documentos/central/page_entregas'

# Arquivo de saída onde será salvo o conteúdo
arquivo_saida = 'resumo_projeto.txt'

def gerar_resumo(caminho, arquivo_saida):
    with open(arquivo_saida, 'w') as f_out:
        # Percorre todas as subpastas e arquivos
        for pasta_atual, subpastas, arquivos in os.walk(caminho):
            for arquivo in arquivos:
                # Caminho completo do arquivo
                caminho_arquivo = os.path.join(pasta_atual, arquivo)
                
                # Somente arquivos com extensão .py
                if arquivo.endswith('.py'):
                    # Escreve o caminho do arquivo no formato desejado
                    f_out.write(f"# {os.path.relpath(pasta_atual, caminho)} - {arquivo}\n\n")

                    # Abre o arquivo e lê o conteúdo
                    with open(caminho_arquivo, 'r') as f_in:
                        conteudo = f_in.read()
                        f_out.write(conteudo)
                    
                    # Adiciona uma quebra de linha entre os arquivos
                    f_out.write("\n\n")

    print(f"Resumo gerado em {arquivo_saida}")

# Executa a função para gerar o resumo
gerar_resumo(caminho_projeto, arquivo_saida)


# utils - __init__.py



# utils - cruzamento leads.py

import pandas as pd

# Função para carregar arquivos TSV codificados em UTF-16
def read_tsv_utf16(filepath):
    try:
        return pd.read_csv(filepath, encoding='utf-16', delimiter='\t')
    except Exception as e:
        print(f"Error loading {filepath}: {e}")
        return pd.DataFrame()

# Caminhos dos arquivos CSV (TSV)
csv_file_paths_september = [
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_1v4DubD66G7YYil4Y1OYlybPEsVr_Syp5_Leads_2024-08-08_2024-09-29.csv',
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_1hInB0tW3O1P5GaIhf3D4w9HbKWV-nB-r _ CARD 5_Leads_2024-07-31_2024-09-29.csv',
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_1myUh2JRRD0Bu9pCqEnsugy3h23BIzBZl_Leads_2024-08-19_2024-09-29.csv',
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_1o0QgalnZd2PlTUhDN4feHgT4w3FaHfBI_Leads_2024-07-31_2024-09-29.csv',
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_15gcvkHd-POyc9sS9kbUJkXIWd1-TbmUY_Leads_2024-07-31_2024-09-29.csv',
    '/home/debrito/Documentos/cruzamento leads/setembro/IG _ dp_1BGLLvPG8Kfv2ZryJ8yL1KPkiSgjH6UQN_Leads_2024-08-27_2024-09-29.csv'
]

# Carregar o relatório de leads de setembro
september_report_path = '/home/debrito/Documentos/cruzamento leads/setembro/Relatorio mês de Setembro.xlsx'
september_data = pd.read_excel(september_report_path)

# Carregar e combinar os dados CSV
tsv_dataframes_september = [read_tsv_utf16(path) for path in csv_file_paths_september]
tsv_dataframes_september = [df for df in tsv_dataframes_september if not df.empty]  # Remover dataframes vazios
combined_tsv_data_september = pd.concat(tsv_dataframes_september, ignore_index=True)

# Cruzar os dados usando o campo 'email' tanto no Excel quanto nos CSVs
merged_september_data = pd.merge(september_data, combined_tsv_data_september[['email', 'ad_name']], how='left', on='email')

# Exportar o resultado para um arquivo Excel
output_september_file_path = '/home/debrito/Documentos/cruzamento leads/setembro/Merged_Leads_September_Data.xlsx'
merged_september_data.to_excel(output_september_file_path, index=False)

print(f"Arquivo final salvo em: {output_september_file_path}")


# utils - assessoria_plan_utils.py

import logging
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy.sql import func
from common.models import Client, RedesSociaisPlan, RedesSociaisGuidance, RedesSociaisPlanStatusEnum
from common.database import engine
import streamlit as st

# Função para salvar a data de envio de um plano ou direcionamento
def salvar_data_envio(cliente_id, data_envio, model_class, status_function):
    logging.info(f"Salvando data de envio para cliente ID {cliente_id} com data {data_envio}")
    with Session(bind=engine) as session:
        try:
            if isinstance(data_envio, datetime):
                data_envio = data_envio.date()

            mes_inicio = data_envio.replace(day=1)
            logging.debug(f"Buscando registro existente para cliente ID {cliente_id} no mês {mes_inicio.strftime('%Y-%m')}")
            record = session.query(model_class).filter(
                model_class.client_id == cliente_id,
                func.strftime('%Y-%m', model_class.send_date) == mes_inicio.strftime('%Y-%m')
            ).first()

            client = session.query(Client).filter(Client.id == cliente_id).first()
            logging.debug(f"Cliente encontrado: {client}")

            # Obter o deadline_day do cliente
            if model_class == RedesSociaisPlan:
                deadline_day = client.monthly_plan_deadline_day
            elif model_class == RedesSociaisGuidance:
                deadline_day = client.monthly_redes_guidance_deadline_day
            else:
                raise ValueError("Classe de modelo desconhecida para determinação do deadline_day")

            if record:
                logging.debug(f"Registro encontrado, atualizando data de envio e status")
                record.send_date = data_envio
                record.updated_at = datetime.now()
                record.status = status_function(client, record, deadline_day)
            else:
                logging.debug(f"Nenhum registro existente encontrado, criando novo registro")
                record = model_class(
                    client_id=cliente_id,
                    send_date=data_envio,
                    updated_at=datetime.now(),
                    status=status_function(client, None, deadline_day),
                    plan_status=RedesSociaisPlanStatusEnum.AWAITING
                )
                session.add(record)

            logging.info(f"Commitando a transação no banco de dados")
            session.commit()
            st.success(f"Data de envio atualizada com sucesso.")
            st.session_state['send_date'] = data_envio

        except Exception as e:
            session.rollback()
            st.error(f"Erro ao atualizar a data de envio: {e}")
            logging.error(f"Erro ao atualizar a data de envio: {e}")

# Função para determinar o status do plano ou direcionamento
def determinar_status(cliente, record, deadline_day):
    hoje = datetime.today().date()
    prazo = datetime(hoje.year, hoje.month, deadline_day).date()
    
    if record is None or record.send_date is None:
        if hoje > prazo:
            return RedesSociaisPlanStatusEnum.DELAYED
        else:
            return RedesSociaisPlanStatusEnum.AWAITING
    else:
        send_date = record.send_date
        if isinstance(send_date, datetime):
            send_date = send_date.date()
        if send_date <= prazo:
            return RedesSociaisPlanStatusEnum.ON_TIME
        else:
            return RedesSociaisPlanStatusEnum.DELAYED

# Função utilitária para obter o range de datas do mês anterior
def get_last_month_date_range():
    today = datetime.today()
    first_day_of_current_month = datetime(today.year, today.month, 1)
    last_day_of_last_month = first_day_of_current_month - timedelta(days=1)
    first_day_of_last_month = datetime(last_day_of_last_month.year, last_day_of_last_month.month, 1)
    return first_day_of_last_month, last_day_of_last_month


# utils - styles.py

  # Definir o CSS para o container apenas da tabela
def css_tabela ():
    
    style = """
    {
        border: 1px dashed lightgray;
        border-radius: 10px;
        padding: 15px;
        margin-top: 10px;
        background-color: white;
    }
    """
    return style 

def css_gauge():
    style = """"
    {   border: 1px solid #d3d3d3;
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 45px;
      }
      """
    return style 

# utils - gauge.py

import plotly.graph_objects as go
import streamlit as st

def display_gauge_chart(title, contracted, used, accumulated=0):
    """
    Função para exibir um gráfico de medidor (gauge) que mostra os valores contratados, usados e acumulados.

    :param title: Título do medidor.
    :param contracted: Valor contratado.
    :param used: Valor usado até o momento.
    :param accumulated: Valor acumulado (positivo ou negativo).
    """
    if accumulated < 0:
        # Quando o acumulado é negativo, considera um déficit
        max_value = contracted  # Mantém o max_value como o contratado quando há um déficit
        deficit_start = contracted + accumulated  # Início do déficit (valor menor que o contratado)
        steps = [
            {'range': [0, deficit_start], 'color': "lightgray"},  # Intervalo até o início do déficit
            {'range': [deficit_start, contracted], 'color': "red"}  # Intervalo do déficit
        ]
        accumulated_color = 'red'
    else:
        # Caso contrário, o acumulado é positivo
        max_value = contracted + accumulated
        steps = [
            {'range': [0, contracted], 'color': "lightgray"},
            {'range': [contracted, max_value], 'color': "orange"}
        ]
        accumulated_color = 'orange'

    # Cria o gráfico de medidor (gauge)
    fig = go.Figure(go.Indicator(
        mode="gauge+number",
        value=used,
        title={'text': title, 'font': {'size': 20}},
        number={'font': {'size': 40}},
        gauge={
            'axis': {'range': [0, max_value], 'tickwidth': 1, 'tickcolor': "darkblue"},
            'bar': {'color': "green"},
            'steps': steps,
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': contracted
            }
        }
    ))

    # Configura o layout e estilo do gráfico
    fig.update_layout(
        autosize=False,
        width=350,
        height=250,
        margin=dict(l=20, r=20, t=50, b=100),
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        annotations=[
            dict(
                x=0.15, y=-0.05, xref='paper', yref='paper',
                text=f"Contratado: {contracted}",
                showarrow=False,
                font=dict(color="white", size=12),
                xanchor='center',
                yanchor='top',
                bgcolor='green',
                borderpad=5,
                borderwidth=2,
                bordercolor='rgba(0,0,0,0)',
                opacity=1
            ),
            dict(
                x=0.8, y=-0.05, xref='paper', yref='paper',
                text=f"<b>Acumulado:</b> {accumulated}",
                showarrow=False,
                font=dict(color="white", size=12),
                xanchor='center',
                yanchor='top',
                bgcolor=accumulated_color,  # Cor de fundo dinâmica baseada no acumulado
                borderpad=5,
                borderwidth=2,
                bordercolor='rgba(0,0,0,0)',
                opacity=1
            )
        ]
    )

    # Renderiza o gráfico no Streamlit
    st.plotly_chart(fig, use_container_width=True)



# utils - timeline.py

# import plotly.graph_objects as go
# import streamlit as st
# import pandas as pd

# def create_timeline_chart(today, deadline_date, event_date=None, event_name="Enviado"):
#     """
#     Cria um gráfico de linha do tempo para exibir prazos e datas de envio.
    
#     :param today: Data atual (datetime object).
#     :param deadline_date: Data do prazo (datetime object).
#     :param event_date: Data do evento, como a data de envio (datetime object), opcional.
#     :param event_name: Nome do evento (ex.: "Enviado"), opcional, padrão é "Enviado".
#     :return: Objeto Plotly figure representando a linha do tempo.
#     """
#     # Gera uma lista com os dias do mês
#     days_in_month = [date for date in pd.date_range(start=today.replace(day=1), end=today.replace(day=28) + pd.offsets.MonthEnd(1))]
#     x_values = [day.strftime('%Y-%m-%d') for day in days_in_month]

#     # Inicializa as listas de eventos
#     event_dates = [deadline_date.strftime('%Y-%m-%d')]
#     event_colors = ["red"]
#     event_texts = ["Deadline"]

#     if event_date:
#         event_dates.append(event_date.strftime('%Y-%m-%d'))
#         event_colors.append("green")
#         event_texts.append(event_name)

#     fig = go.Figure()

#     # Adiciona a linha do tempo com os dias do mês
#     fig.add_trace(go.Scatter(
#         x=x_values,
#         y=[1] * len(x_values),
#         mode='lines+markers',
#         line=dict(color='lightgrey', width=2),
#         marker=dict(color='lightgrey', size=6),
#         hoverinfo='x',
#         showlegend=False
#     ))

#     # Adiciona os eventos (prazos, envio, etc.) com as legendas
#     for date, color, text in zip(event_dates, event_colors, event_texts):
#         text_position = "top center" if text == event_name else "bottom center"
#         fig.add_trace(go.Scatter(
#             x=[date],
#             y=[1],
#             mode='markers+text',
#             marker=dict(color=color, size=12),
#             text=[text],
#             textposition=text_position,
#             showlegend=False,
#             hoverinfo='none'
#         ))

#     # Configuração do layout do gráfico
#     fig.update_layout(
#         xaxis=dict(
#             tickmode='array',
#             tickvals=x_values,
#             ticktext=[day.strftime('%d') for day in days_in_month],
#             showline=False,
#             showgrid=False,
#             zeroline=False,
#             tickfont=dict(size=10),
#             tickangle=0,
#             ticks='outside',
#             ticklen=4,
#             tickwidth=1,
#         ),
#         yaxis=dict(visible=False),
#         height=95,
#         margin=dict(l=20, r=20, t=10, b=10),
#         plot_bgcolor='rgba(0,0,0,0)',
#         paper_bgcolor='rgba(0,0,0,0)',
#     )

#     return fig

# def render_timeline_chart(today, deadline_date, event_date=None, event_name="Enviado"):
#     """
#     Renderiza o gráfico de linha do tempo no Streamlit.
    
#     :param today: Data atual (datetime object).
#     :param deadline_date: Data do prazo (datetime object).
#     :param event_date: Data do evento, como a data de envio (datetime object), opcional.
#     :param event_name: Nome do evento (ex.: "Enviado"), opcional, padrão é "Enviado".
#     """
#     fig = create_timeline_chart(today, deadline_date, event_date, event_name)
#     st.plotly_chart(fig, use_container_width=True)

# def render_timeline_chart_with_multiple_events(today, deadline_date, event_dates):
#     """
#     Renderiza um gráfico de linha do tempo com múltiplos eventos, como manutenção de websites.
    
#     :param today: Data atual (datetime object).
#     :param deadline_date: Data do prazo (datetime object).
#     :param event_dates: Lista de datas de eventos.
#     """
#     days_in_month = [date for date in pd.date_range(start=today.replace(day=1), end=deadline_date)]
#     x_values = [day.strftime('%Y-%m-%d') for day in days_in_month]

#     fig = go.Figure()

#     # Adicionando a linha do tempo com os dias do mês
#     fig.add_trace(go.Scatter(
#         x=x_values,
#         y=[1] * len(x_values),
#         mode='lines+markers',
#         line=dict(color='lightgrey', width=2),
#         marker=dict(color='lightgrey', size=6),
#         hoverinfo='x',
#         showlegend=False
#     ))

#     # Adicionando os eventos de manutenção
#     for date in event_dates:
#         fig.add_trace(go.Scatter(
#             x=[date.strftime('%Y-%m-%d')],
#             y=[1],
#             mode='markers+text',
#             marker=dict(color='green', size=12),
#             text=["Manutenção"],
#             textposition="top center",
#             showlegend=False,
#             hoverinfo='none'
#         ))

#     # Configura o layout do gráfico
#     fig.update_layout(
#         xaxis=dict(
#             tickmode='array',
#             tickvals=x_values,
#             ticktext=[day.strftime('%d') for day in days_in_month],
#             showline=False,
#             showgrid=False,
#             zeroline=False,
#             tickfont=dict(size=10),
#             tickangle=0,
#             ticks='outside',
#             ticklen=4,
#             tickwidth=1,
#         ),
#         yaxis=dict(visible=False),
#         height=150,
#         margin=dict(l=20, r=20, t=10, b=10),
#         plot_bgcolor='rgba(0,0,0,0)',
#         paper_bgcolor='rgba(0,0,0,0)',
#     )

#     # Renderiza o gráfico no Streamlit
#     st.plotly_chart(fig, use_container_width=True)


# plan_status - plan_timeline.py

# import streamlit as st
# from common.models import Client, RedesSociaisPlan
# from page_entregas.utils.assessoria_plan_utils import determinar_status
# from page_entregas.utils.timeline import render_timeline_chart


# from sqlalchemy.orm import Session
# from datetime import datetime, timedelta

# # Função para exibir a linha do tempo do plano de redes sociais
# def display_plan_timeline(cliente_id):
#     with Session(bind=st.session_state["engine"]) as session:
#         # Busca os dados do cliente e o plano de redes sociais
#         client = session.query(Client).filter(Client.id == cliente_id).first()
#         redes_sociais_plan = session.query(RedesSociaisPlan).filter(RedesSociaisPlan.client_id == cliente_id).first()

#         # Determina o status do plano e a data de envio do plano
#         if redes_sociais_plan:
#             plan_status = determinar_status(client, redes_sociais_plan, client.monthly_plan_deadline_day)
#             if 'plan_sent_date' not in st.session_state or not st.session_state['plan_sent_date']:
#                 st.session_state['plan_sent_date'] = redes_sociais_plan.send_date
#         else:
#             plan_status = "Plano não encontrado"
#             st.session_state['plan_sent_date'] = None

#         # Gera o título para a linha do tempo com base no próximo mês
#         next_month = (datetime.now().replace(day=28) + timedelta(days=4)).strftime('%B')
#         title = f"Planejamento Redes Sociais: {next_month.capitalize()}"

#         # Exibe o título
#         st.write(f"**{title}**")

#         # Define a data de hoje e a data do deadline
#         today = datetime.today()
#         deadline_date = datetime(today.year, today.month, client.monthly_plan_deadline_day)

#         # Renderiza a linha do tempo do plano
#         render_timeline_chart(today, deadline_date, st.session_state['plan_sent_date'])


# plan_status - __init__.py



# plan_status - plan_modal.py

# import streamlit as st
# from page_entregas.utils.assessoria_plan_utils import salvar_data_envio, determinar_status
# from common.models import RedesSociaisPlan
# from streamlit_modal import Modal
# from datetime import datetime
# import logging

# # Função para exibir o modal de envio do plano
# def display_plan_modal(cliente_id):
#     # Inicializa o modal fora dos containers estilizados
#     modal = Modal("Data de Envio do Plano", key="enviar-plano-modal", max_width=800)

#     if st.button("Enviar Plano"):
#         logging.info(f"Usuário clicou no botão 'Enviar Plano' para o cliente ID {cliente_id}")
#         modal.open()

#     # Verifica e abre o modal fora do container
#     if modal.is_open():
#         logging.info(f"Modal 'Data de Envio do Plano' foi aberto para o cliente ID {cliente_id}")
#         with modal.container():
#             selected_date = st.date_input("Selecione a Data de Envio", value=datetime.today())
#             if st.button("Confirmar"):
#                 logging.info(f"Tentando salvar a data de envio para o cliente ID {cliente_id}")
#                 salvar_data_envio(cliente_id, selected_date, RedesSociaisPlan, determinar_status)
#                 st.session_state['plan_sent_date'] = selected_date
#                 modal.close()  # Fecha o modal
#                 st.success("Data de envio do plano atualizada com sucesso!")
#                 st.rerun()  # Recarrega a página para refletir as mudanças


# guidance_status - guidance_timeline.py

# import streamlit as st
# from datetime import datetime, timedelta
# from common.models import Client, RedesSociaisGuidance
# from page_entregas.utils.assessoria_plan_utils import determinar_status
# from page_entregas.utils.timeline import render_timeline_chart
# from sqlalchemy.orm import Session
# from common.database import engine

# # Função para exibir a linha do tempo do direcionamento
# def display_guidance_timeline(cliente_id):
#     # Abrindo uma sessão com o banco de dados
#     with Session(bind=engine) as session:
#         # Consultando o cliente e o status do direcionamento
#         client = session.query(Client).filter(Client.id == cliente_id).first()
#         redes_sociais_guidance = session.query(RedesSociaisGuidance).filter(RedesSociaisGuidance.client_id == cliente_id).first()

#         # Verificando se o direcionamento existe
#         if redes_sociais_guidance:
#             # Determina o status do direcionamento e recupera a data de envio
#             guidance_status = determinar_status(client, redes_sociais_guidance, client.monthly_redes_guidance_deadline_day)
#             if 'guidance_send_date' not in st.session_state or not st.session_state['guidance_send_date']:
#                 st.session_state['guidance_send_date'] = redes_sociais_guidance.send_date
#         else:
#             guidance_status = "Direcionamento não encontrado"
#             st.session_state['guidance_send_date'] = None

#         # Exibir o título da linha do tempo
#         next_month = (datetime.now().replace(day=28) + timedelta(days=4)).strftime('%B')
#         title = f"Direcionamento Redes Sociais: {next_month.capitalize()}"
#         st.write(f"**{title}**")

#         # Definir datas importantes
#         today = datetime.today()
#         deadline_date = datetime(today.year, today.month, client.monthly_redes_guidance_deadline_day)

#         # Renderizar a linha do tempo
#         render_timeline_chart(today, deadline_date, st.session_state['guidance_send_date'])


# guidance_status - __init__.py



# guidance_status - guidance_modal.py

# import streamlit as st
# from datetime import datetime
# from streamlit_modal import Modal
# from common.models import RedesSociaisGuidance
# from page_entregas.utils.assessoria_plan_utils import salvar_data_envio, determinar_status
# import logging



# # Função para exibir o modal de envio do direcionamento
# def display_guidance_modal(cliente_id):
#     # Inicializa o modal com título
#     modal = Modal("Data de Envio do Direcionamento", key="enviar-direcionamento-modal", max_width=800)

#     # Verifica se o modal foi solicitado (se o botão foi clicado)
#     if st.button("Enviar Direcionamento"):
#         logging.info(f"Usuário clicou no botão 'Enviar Direcionamento' para o cliente ID {cliente_id}")
#         modal.open()

#     # Verifica se o modal está aberto
#     if modal.is_open():
#         logging.info(f"Modal 'Data de Envio do Direcionamento' foi aberto para o cliente ID {cliente_id}")
        
#         # Conteúdo do modal
#         with modal.container():
#             # Input para seleção da data de envio
#             selected_date = st.date_input("Selecione a Data de Envio", value=datetime.today())
            
#             # Botão para confirmar a data selecionada
#             if st.button("Confirmar"):
#                 logging.info(f"Tentando salvar a data de envio do direcionamento para o cliente ID {cliente_id}")
                
#                 # Salvar a data de envio no banco de dados
#                 salvar_data_envio(cliente_id, selected_date, RedesSociaisGuidance, determinar_status)
                
#                 # Atualiza a sessão com a nova data
#                 st.session_state['guidance_send_date'] = selected_date
#                 modal.close()  # Fecha o modal
#                 st.success("Data de envio do direcionamento atualizada com sucesso!")
#                 st.rerun()  # Recarrega a página para refletir as mudanças


# content_production - content_production_gauge_modals .py

import streamlit as st
from streamlit_modal import Modal
from sqlalchemy.orm import Session
import logging
from common.models import  DeliveryControl
from datetime import datetime

def edit_content_production_meeting(engine, item_id, modal):
    if modal.is_open():
        with Session(bind=engine) as session:
            content_production_meeting = session.query(DeliveryControl).get(item_id)

            if content_production_meeting is None:
                st.error("Reunião de Produção de Conteúdo não encontrada.")
                modal.close()
                return

            # Exibir o conteúdo do modal
            with modal.container():
                st.write("### Editar Reunião de Produção de Conteúdo")

                # Exibir o formulário dentro do modal
                with st.form(key=f'edit_form_{item_id}'):
                    selected_date = st.date_input("Selecione a Data da Reunião", value=content_production_meeting.date)
                    subject = st.text_area("Tema da Reunião", value=content_production_meeting.subject)
                    meeting_notes = st.text_area("Notas", value=content_production_meeting.notes)
                    submit_edit = st.form_submit_button(label='Salvar Alterações')

                    if submit_edit:
                        if subject:
                            try:
                                content_production_meeting.date = selected_date
                                content_production_meeting.subject = subject
                                content_production_meeting.notes = meeting_notes
                                session.commit()
                                st.success("Reunião atualizada com sucesso!")
                                modal.close()  # Fechar o modal
                                st.rerun()
                            except Exception as e:
                                st.error(f"Erro ao atualizar a Reunião de Produção de Conteúdo: {e}")
                                logging.error(f"Erro ao atualizar reunião de produção de conteúdo: {e}")
                        else:
                            st.error("A descrição da reunião não pode estar vazia.")
    else:
        modal.close()

def delete_content_production_meeting_meeting_modal(engine, item_id, modal):
    if modal.is_open():
        with Session(bind=engine) as session:
            content_production_meeting = session.query(DeliveryControl).get(item_id)

            if content_production_meeting is None:
                st.error("Reunião não encontrada.")
                modal.close()
                return

            # Exibir o conteúdo do modal
            with modal.container():
                st.write("### Excluir Reunião de Produção de Conteúdo")
                st.warning(f"Tem certeza que deseja excluir a Reunião de Produção de Conteúdo do dia {content_production_meeting.date.strftime('%d %b. %Y')}? Esta ação não pode ser desfeita.")

                # Botões de confirmação e cancelamento
                col1, col2 = st.columns(2)
                with col1:
                    confirm_delete = st.button("Excluir", key=f'confirm_delete_meeting{item_id}')
                with col2:
                    cancel_delete = st.button("Cancelar", key=f'cancel_delete_meeting{item_id}')

                if confirm_delete:
                    try:
                        session.delete(content_production_meeting)
                        session.commit()
                        st.success("Reunião excluída com sucesso!")
                        modal.close()
                        st.rerun()
                    except Exception as e:
                        st.error(f"Erro ao excluir a Reunião de Produção de Conteúdo: {e}")
                        logging.error(f"Erro ao excluir a Reunião de Produção de Conteúdo: {e}")
                elif cancel_delete:
                    modal.close()
                    st.rerun()
    else:
        modal.close()

def add_content_production_meeting_meeting_modal(engine):
    # Inicializa o modal para adicionar Reunião de Produção de Conteúdo
    modal = Modal("Adicionar Nova Reunião de Produção de Conteúdo", key="adicionar_reunião_conteudo", padding=20, max_width=744)

    # Botão para abrir o modal
    if st.button("Adicionar Reunião de Conteúdo"):
        modal.open()

    # Exibir o modal se estiver aberto
    if modal.is_open():
        with modal.container():
            st.write("### Nova Reunião de Produção de Conteúdo")
            with st.form(key='new_content_production_meeting_form'):
                selected_date = st.date_input("Selecione a Data do Reunião de Produção de Conteúdo", value=datetime.today())
                subject = st.text_area("Assunto da Reunião de Produção de Conteúdo")
                meeting_notes = st.text_area("Notas da Reunião")
                submit_new = st.form_submit_button(label='Salvar')

                if submit_new:
                    if subject:
                        save_new_content_production_meeting_meeting(st.session_state["cliente_id"], selected_date, subject, meeting_notes, engine)
                        st.success("Reunião adicionada com sucesso!")
                        modal.close()
                        st.rerun()
                    else:
                        st.error("A descrição da Reunião de Produção de Conteúdo não pode estar vazia.")

def save_new_content_production_meeting_meeting(cliente_id, production_date, subject, notes, engine):
    try:
        if engine is None:
            raise ValueError("Engine não foi fornecido")
        with Session(bind=engine) as session:
            new_entry = DeliveryControl(
                client_id=cliente_id,
                date=production_date,
                subject=subject,
                notes=notes
            )
            session.add(new_entry)
            session.commit()  # Commit da nova entrada
            st.success("Reunião de produção de conteúdo salva com sucesso!")
    except Exception as e:
        st.error(f"Erro ao salvar a reunião de produção de conteúdo: {e}")

        # Log de erro detalhado
        logging.error(f"Erro ao salvar a reunião de produção de conteúdo: {e}")
        st.error(f"Erro ao salvar a reunião de produção de conteúdo: {e}")

# content_production - content_production_table_modals.py

import streamlit as st
from streamlit_modal import Modal
from sqlalchemy.orm import Session
import logging
from common.models import ContentProduction
from datetime import datetime

def edit_content_production_meeting_modal(engine, item_id, modal):
    if modal.is_open():
        with Session(bind=engine) as session:
            content_production = session.query(ContentProduction).get(item_id)

            if content_production is None:
                st.error("Reunião de Produção de Conteúdo não encontrada.")
                modal.close()
                return

            # Exibir o conteúdo do modal
            with modal.container():
                st.write("### Editar Reunião de Produção de Conteúdo")

                # Exibir o formulário dentro do modal
                with st.form(key=f'edit_form_{item_id}'):
                    selected_date = st.date_input("Selecione a Data da Reunião", value=content_production.date)
                    subject = st.text_area("Tema da Reunião", value=content_production.subject)
                    meeting_notes = st.text_area("Notas", value=content_production.notes)
                    submit_edit = st.form_submit_button(label='Salvar Alterações')

                    if submit_edit:
                        if subject:
                            try:
                                content_production.date = selected_date
                                content_production.subject = subject
                                content_production.notes = meeting_notes
                                session.commit()
                                st.success("Reunião atualizada com sucesso!")
                                modal.close()  # Fechar o modal
                                st.rerun()
                            except Exception as e:
                                st.error(f"Erro ao atualizar a Reunião de Produção de Conteúdo: {e}")
                                logging.error(f"Erro ao atualizar reunião de produção de conteúdo: {e}")
                        else:
                            st.error("A descrição da reunião não pode estar vazia.")
    else:
        modal.close()

def delete_content_production_meeting_modal(engine, item_id, modal):
    if modal.is_open():
        with Session(bind=engine) as session:
            content_production = session.query(ContentProduction).get(item_id)

            if content_production is None:
                st.error("Reunião não encontrada.")
                modal.close()
                return

            # Exibir o conteúdo do modal
            with modal.container():
                st.write("### Excluir Reunião de Produção de Conteúdo")
                st.warning(f"Tem certeza que deseja excluir a Reunião de Produção de Conteúdo do dia {content_production.date.strftime('%d %b. %Y')}? Esta ação não pode ser desfeita.")

                # Botões de confirmação e cancelamento
                col1, col2 = st.columns(2)
                with col1:
                    confirm_delete = st.button("Excluir", key=f'confirm_delete_meeting{item_id}')
                with col2:
                    cancel_delete = st.button("Cancelar", key=f'cancel_delete_meeting{item_id}')

                if confirm_delete:
                    try:
                        session.delete(content_production)
                        session.commit()
                        st.success("Reunião excluída com sucesso!")
                        modal.close()
                        st.rerun()
                    except Exception as e:
                        st.error(f"Erro ao excluir a Reunião de Produção de Conteúdo: {e}")
                        logging.error(f"Erro ao excluir a Reunião de Produção de Conteúdo: {e}")
                elif cancel_delete:
                    modal.close()
                    st.rerun()
    else:
        modal.close()

def add_content_production_meeting_modal(engine):
    # Inicializa o modal para adicionar Reunião de Produção de Conteúdo
    modal = Modal("Adicionar Nova Reunião de Produção de Conteúdo", key="adicionar_reunião_conteudo", padding=20, max_width=744)

    # Botão para abrir o modal
    if st.button("Adicionar Reunião de Conteúdo"):
        modal.open()

    # Exibir o modal se estiver aberto
    if modal.is_open():
        with modal.container():
            st.write("### Nova Reunião de Produção de Conteúdo")
            with st.form(key='new_content_production_form'):
                selected_date = st.date_input("Selecione a Data do Reunião de Produção de Conteúdo", value=datetime.today())
                subject = st.text_area("Assunto da Reunião de Produção de Conteúdo")
                meeting_notes = st.text_area("Notas da Reunião")
                submit_new = st.form_submit_button(label='Salvar')

                if submit_new:
                    if subject:
                        save_new_content_production_meeting(st.session_state["cliente_id"], selected_date, subject, meeting_notes, engine)
                        st.success("Reunião adicionada com sucesso!")
                        modal.close()
                        st.rerun()
                    else:
                        st.error("A descrição da Reunião de Produção de Conteúdo não pode estar vazia.")

def save_new_content_production_meeting(cliente_id, production_date, subject, notes, engine):
    try:
        if engine is None:
            raise ValueError("Engine não foi fornecido")
        with Session(bind=engine) as session:
            new_entry = ContentProduction(
                client_id=cliente_id,
                date=production_date,
                subject=subject,
                notes=notes
            )
            session.add(new_entry)
            session.commit()  # Commit da nova entrada
            st.success("Reunião de produção de conteúdo salva com sucesso!")
    except Exception as e:
        st.error(f"Erro ao salvar a reunião de produção de conteúdo: {e}")

        # Log de erro detalhado
        logging.error(f"Erro ao salvar a reunião de produção de conteúdo: {e}")
        st.error(f"Erro ao salvar a reunião de produção de conteúdo: {e}")

# content_production - __init__.py



# content_production - content_production_gauge.py

import streamlit as st
from streamlit_extras.stylable_container import stylable_container
from page_entregas.utils.gauge import display_gauge_chart
from common.models import DeliveryCategoryEnum

def display_content_production_gauge(mandalecas_contratadas, mandalecas_usadas, mandalecas_acumuladas):
    """
    Exibe o gauge (gráfico de medidor) para produção de conteúdo.
    """
    st.write("**Produção de Conteúdo**")
    
    with stylable_container(key="content_production_gauge", 
                            css_styles="""
                            {
                                border: 1px solid #d3d3d3;
                                border-radius: 10px;
                                padding: 15px;
                                margin-bottom: 45px;
                            }
                            """):
        # Obter os valores específicos para a categoria de Produção de Conteúdo
        contracted = mandalecas_contratadas.get(DeliveryCategoryEnum.CONTENT_PRODUCTION, 0)
        used = mandalecas_usadas.get(DeliveryCategoryEnum.CONTENT_PRODUCTION, 0)
        accumulated = mandalecas_acumuladas.get(DeliveryCategoryEnum.CONTENT_PRODUCTION, 0)

        # Exibir o gráfico de gauge
        display_gauge_chart(
            title="Produção de Conteúdo",
            contracted=contracted,
            used=used,
            accumulated=accumulated
        )


# content_production - content_production_table.py

import streamlit as st
from sqlalchemy.orm import Session
import pandas as pd
from common.models import ContentProduction
import logging
from page_entregas.utils.styles import css_tabela
from page_entregas.content_production.content_production_table_modals import (
    edit_content_production_meeting_modal,
    delete_content_production_meeting_modal,
    add_content_production_meeting_modal
)
from streamlit_modal import Modal
from streamlit_extras.stylable_container import stylable_container

# Configuração do logging
logging.basicConfig(
    filename='logs/content_production.log',  # Nome do arquivo onde os logs serão salvos
    level=logging.ERROR,  # Nível do log (ERROR para registrar erros)
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)


def display_content_production_table(cliente_id, data_inicio, data_fim, engine):
    """
    Exibe a tabela de reuniões de produção de conteúdo para um cliente, em um intervalo de datas,
    com botões de Editar e Excluir, encapsulada em um container estilizado.
    """
    try:
        # Iniciar uma sessão do SQLAlchemy para buscar as reuniões de produção de conteúdo
        with Session(bind=engine) as session:
            content_production = session.query(ContentProduction).filter(
                ContentProduction.client_id == cliente_id,
                ContentProduction.date.between(data_inicio, data_fim)
            ).order_by(ContentProduction.date.desc()).all()

        # Verificar se há reuniões de produção de conteúdo
        if not content_production:
            st.info("Nenhuma reunião de produção de conteúdo encontrada para o período selecionado.")
        else:
            # Criar uma lista de dicionários para armazenar as reuniões
            data = []
            for cp in content_production:
                data.append({
                    'Data': cp.date.strftime('%d %b. %Y') if cp.date else '',
                    'Tema da Reunião': cp.subject,
                    'Notas': cp.notes if cp.notes else '-',
                    'ID': cp.id
                })

            # Converter os dados em DataFrame para facilitar a exibição
            content_production_df = pd.DataFrame(data)

            st.write("**Reuniões de Produção de Conteúdo**")

            # Inicializar os modais fora de qualquer container ou loop
            edit_modal = Modal("Editar Reunião", key="edit_modal_cp", max_width=800)
            delete_modal = Modal("Excluir Reunião", key="delete_modal_cp", max_width=800)

            # Exibir a tabela dentro do container estilizado
            with stylable_container(
                key="tabela_content_production",
                css_styles=css_tabela()
            ):
                # Criar cabeçalho da tabela
                header_cols = st.columns([2, 5, 5, 1, 1])
                header_cols[0].write("**Data**")
                header_cols[1].write("**Tema da Reunião**")
                header_cols[2].write("**Notas**")
                header_cols[3].write("**Editar**")
                header_cols[4].write("**Excluir**")

                # Exibir os dados com botões de ação
                for index, row in content_production_df.iterrows():
                    # Definir a cor de fundo com base na paridade do índice
                    row_bg_color = '#FFFFFF' if index % 2 == 0 else '#F0F0F0'

                    # Aplicar o estilo à linha usando stylable_container
                    with stylable_container(
                        key=f'row_{row["ID"]}_{index}',
                        css_styles=f'''
                        background-color: {row_bg_color};
                        padding: 5px;
                        border-radius: 5px;
                        '''
                    ):
                        cols = st.columns([2, 5, 5, 1, 1])
                        cols[0].write(row['Data'])
                        cols[1].write(row['Tema da Reunião'])
                        cols[2].write(row['Notas'])
                        if cols[3].button('✏️', key=f'edit_{row["ID"]}_{index}', help='Editar'):
                            st.session_state['edit_item_id'] = row['ID']
                            edit_modal.open()
                        if cols[4].button('🗑️', key=f'delete_{row["ID"]}_{index}', help='Excluir'):
                            st.session_state['delete_item_id'] = row['ID']
                            delete_modal.open()

            # Chamar as funções dos modais fora do container e de qualquer loop
            if edit_modal.is_open():
                edit_content_production_meeting_modal(engine, st.session_state['edit_item_id'], edit_modal)

            if delete_modal.is_open():
                delete_content_production_meeting_modal(engine, st.session_state['delete_item_id'], delete_modal)

        # Botão para adicionar nova reunião
        add_content_production_meeting_modal(engine)

    except Exception as e:
        # Adicionar logging para erros inesperados
        logging.error(f"Erro ao exibir a tabela de produção de conteúdo: {e}")
        st.error("Ocorreu um erro ao carregar os dados de produção de conteúdo. Por favor, tente novamente mais tarde.")




